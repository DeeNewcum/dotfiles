#!/usr/bin/env perl
#
# This file is generated code.
# Please DO NOT EDIT or send patches for it.
#
# Please take a look at the source from
#    https://github.com/DeeNewcum/termdetect
# and submit patches against the individual files
# that build it.
#



# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Termdetect_Encoding.pm"} = <<'TERMDETECT_ENCODING';
  # This performs tests on the terminal, to try to determine what character-encoding the terminal
  # is set to.
  
  
  package Termdetect_Encoding;
  
      use strict;
      use warnings;
  
      use Termdetect_IO;
      use bytes qw();
  
      use Data::Dumper;
  
      use Exporter 'import';
      our @EXPORT = qw( do_encoding_tests );
  
  
  
  # TODO: We need to determine what the canonical names for these should be.
  #       Our main intention is for filling out the $LANG locale variable, however, 
  #       the "The Open Group Base Specifications Issue 6" says:
  #               "settings of language, territory, and codeset are implementation-defined"
  #
  #       For now, we're using the encoding name found on linux  (run `locale -a` or `locale -m`)
  
  
  # each test consists of:
  #       - one or more octets that we will send to the terminal
  #       - the expected X movement of the cursor in response to these octets
  #       - the expected Y movement of the cursor in response to these octets
  our %encoding_tests = (
  
      'utf8' => {
          # in case there are any font-support issues, (I think I've seen cases where missing glyphs
          # resulted in the character being rendered as [2, 0]) the codepoints that have named HTML
          # entities are somewhat more likely to be supported by most fonts?
          #       http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML
  
          'C2 A9'         => [1, 0],      # copyright symbol
          'C3 86'         => [1, 0],      # AE ligature
          'E2 80 94'      => [1, 0],      # em-dash
          'E2 99 A3'      => [1, 0],      # clubs symbol
      },
  
      'gb2312' => {
          'A1 A1'         => [2, 0],      # ideographic space
          'A1 DE'         => [1, 0],      # infinity symbol
          'A1 EA'         => [2, 0],      # fullwidth pound sign
          'A1 FE'         => [2, 0],      # geta mark
          'A1 EA'         => [2, 0],      # fullwidth pound sign
          'A2 C6'         => [1, 0],      # parenthesized digit two
          'A2 DA'         => [1, 0],      # circled digit two
          'A6 C8'         => [1, 0],      # theta
      },
  
      'shift_jis' => {
          '81 83'         => [2, 0],      # fullwidth less-than sign
          '81 E1'         => [1, 0],      # much less-than
          '81 CE'         => [1, 0],      # there exists
          '81 BE'         => [1, 0],      # union
          '81 BF'         => [1, 0],      # intersection
          '82 81'         => [2, 0],      # fullwidth latin small letter A
      }
  
  );
  
  
  sub do_encoding_tests {
      my $all_results = shift;
  
      my %encoding_results;
  
      # Do a union set-operation on all tests.  We will run all tests, regardless of which encoding
      # they're attached to.
      my @encoding_tests = uniq(map {keys %$_} values %encoding_tests);
          #print Dumper \@encoding_tests; exit;
  
      my %still_matching = map {$_ => 1}
                               keys %encoding_tests;
      foreach my $encoding_test (@encoding_tests) {
          debug_log("encoding $encoding_test\n");
          my $bytes = join "",
                      map {bytes::chr(hex($_))}
                          split ' ', $encoding_test;
          output("\r");
          run_test($bytes . "K",
                   sub {
                      my ($test_result) = @_;
                      process_encoding_results($encoding_test, $test_result, \%still_matching);
                   });
                  
      }
  
      read_phase {
          # record the final conclusion of the encoding tests
          if (scalar(keys(%still_matching)) == 1) {
              ($all_results->{s_encoding}{received}) = keys %still_matching;
          }
      };
  }
  
  
  sub process_encoding_results {
      my ($encoding_test, $test_result, $still_matching) = @_;
  
      foreach my $encoding (keys %$still_matching) {
          next unless exists $encoding_tests{$encoding}{$encoding_test};
          my $expected = $encoding_tests{$encoding}{$encoding_test};
  
          # backup one, since we printed an extra character ("K") at the end
          $test_result->{x_delta} = ($test_result->{x_delta} || 0) - 1;       
  
          # for newlines, we only care about delta-Y, we ignore delta-X
          if ($expected->[1] && $expected->[1] != ($test_result->{y_delta} || 0)
                  || $expected->[0] != ($test_result->{x_delta} || 0))
          {
              delete $still_matching->{$encoding};
  
              if (0) {                # set this to '1' to do the equivalent of --check for encodings
                  my $result = sprintf "(%d, %d)",
                                       $test_result->{x_delta} || 0,
                                       $test_result->{y_delta} || 0;
                  print "FAILED MATCH on encoding=$encoding and test='$encoding_test'.  Result was: $result\n\n\n";
              }
          }
      }
  }
  
  
  
  # removes duplicate elements from a list
  sub uniq {
      my %seen;
      grep { !$seen{$_}++ }
           @_
  }
  
  
  #use Encode;
  #sub xxd {Encode::_utf8_off(my$str=shift);open my$xxd,'|-','xxd'or die$!;print$xxd $str;close$xxd}    
  
  
  1;
  
  
  # Copyright (C) 2012  Dee Newcum
  # https://github.com/DeeNewcum/
  #
  # You may redistribute this program and/or modify it under the terms of the GNU
  # General Public License as published by the Free Software Foundation; either
  # version 2 of the License, or (at your option) any later version.
TERMDETECT_ENCODING

$fatpacked{"Termdetect_IO.pm"} = <<'TERMDETECT_IO';
  # This module handles the lower-level I/O with the terminal -- sending ANSI sequences, and reading
  # responses.
  
  
  package Termdetect_IO;
  
      use strict;
      use warnings;
  
      use Time::HiRes qw[alarm];
      #use Term::ReadKey;
  
      use Data::Dumper;
  
      use Exporter 'import';
  
      our @EXPORT = qw(   run_test  read_phase  read_ansi_reply  output  cooked_mode
                          do_queued_async_reads debug_log );
  
  
      # constants
      our $DEBUG = 0;     # turns on lots of debugging
  
          # To watch the debug logs, run this command in another window:
          #     tail -fs0 --retry /var/tmp/termdetect.debug\n";
  
      our $ASYNC = 1;     # Should reads be done asynchronously?
                          # If things are confusing AT ALL, just set this to 0 and debug from there.
                          # In theory, both modes should act exactly the same (except synchronous
                          # takes longer).  However, async won't work correctly if the reads get
                          # misaligned.
  
      our $CHECK_ALIGNMENT = 0;
                          # Do some extra work to check that reads/writes are aligned properly.
                          # This makes the tests go *much* slower, but it's worth it to 
                          # find out where misalignment is happening.
                          #
                          # While testing, do NOT press any keys on the keyboard.
  
      our $EXTRA_DELAY = 0.20;            # (seconds)
                          # Add this much extra delay in between each test.
                          # Good choices range from 0.1 to 2.0.
                          # This is inactive unless $DEBUG is true.
  
      if ($DEBUG) {
          # turn on maximum debugging
          $CHECK_ALIGNMENT = 1;
          $ASYNC = 0;
      }
  
      # prototypes
      sub read_phase(&);
  
      # globals
      our @read_queue;
      our $debug_fh;
  
  
  debug__open_log();
  
  
  # From the outside, this routine merely sends an ANSI query, and reads the reply.
  # Internally though, we do it a somewhat fairly sophisticated way.  We surround the request with a
  # CPR queries both before and after, which means that 1) we know if the query caused the cursor
  # to move, and 2) if the terminal doesn't send any reply at all, we know that too, without having
  # to do any waiting.
  sub run_test {
      my ($sequence, $cps, $timeout, $no_cr) = @_;
      $cps ||= sub{};     # CPS = continuation-passing style
      $timeout = 2.0  unless defined($timeout);       # in floating-point seconds
                          # $no_cr -- usually we do a \r right before running the test;  setting this
                          #           to true disables that behavior
  
      my $test_result = {
          sent => $sequence,
      };
  
      if ($sequence =~ /^(?:\e\[|\x9B)\??6n$/) {
          # run_test() isn't designed to work with a Cursor Position Report command.  This is because
          # it uses a CPR-reply as a way to know when to stop reading.
          #
          # When we're asked to do a CPR sequence, we'll revert to much dumbed-down behavior instead.
          
          output("\r")        unless $no_cr;
          output($sequence,
                "\e[5n");      # add a DSR (device status report) to the end, so we can at least
                              # quickly determine a non-response
                              
          read_phase {
              my $reply = read_ansi_reply($timeout, 'n');
              $reply =~ s/\e\[\d+n$//s;
  
              $test_result->{received} = $reply;
              @_ = $test_result;  goto &$cps;       # continuation-passing style
          };
          return;
      }
  
      output("\r")    unless $no_cr;
      output("\e[6n", $sequence, "\e[6n");      # send a CPR (cursor position report) before and after
      #debug_show_remaining_input();
  
      read_phase {
          my $replies = '';
          my $start = time();
          while (1) {
              my $reply = read_ansi_reply($timeout, 'R');
              if (!defined($reply)) {
                  $test_result->{timeout} = 1;
                  last;
              }
              $replies .=  $reply;
  
              if ($replies =~ /.*\e\[(\d+);(\d+)R(.*)\e\[(\d+);(\d+)R/s) {
                  $test_result->{x_delta}  = $5 - $2;
                  $test_result->{y_delta}  = $4 - $1;
                  $test_result->{received} = $3;
  
                  if ($test_result->{y_delta} > 0) {
                      # if this test caused us to move down some lines, then
                      # move back up, to ensure that all "gibberish" is confined to a single line
                      output(("\r"        # move to the beginning of the line
                            . "\e[K"      # erase to end of line
                            . "\e[A")     # move up one line
                                  x $test_result->{y_delta});
                  }
  
                  @_ = $test_result;  goto &$cps;    # continuation-passing style
              }
  
              if (time() - $start > $timeout) {
                  $test_result->{timeout} = 1;
                  last;
              }
          }
          $replies =~ s/^.*?\e\[\d+;\d+R//s;
          $test_result->{received} = $replies;
          @_ = $test_result;  goto &$cps;    # continuation-passing style
      };
  }
  
  
  # There are two phases to every ANSI test:  1) write phase, 2) read phase.
  #
  # If we do all of the read phases AFTER doing all of the write phases (ie. do the reads
  # asynchronously), then the whole process goes much faster.  We minimize latency by doing this.
  sub read_phase(&) {
      my ($callback) = @_;
      if ($ASYNC && ! $CHECK_ALIGNMENT) {
          # run the callback asynchronously
          push(@read_queue, $callback);
      } else {
          # run the callback immediately, in-line
          $callback->();
  
          if ($CHECK_ALIGNMENT) {
              local $DEBUG = 0;       # don't show debugging output...  we INTEND to always timeout inside read_ansi_reply()
              my $any_more_reads = read_ansi_reply(0.1);      # the fractional number here can range from 0.1 to 2.0, depending on how slow the link between them is
              if (length($any_more_reads)) {
                  eval 'use Carp';                        # We don't want to rely on any non-core libraries unless really needed.  This will only be needed in development.
                  Carp::confess("out of alignment\n");
              }
          }
      }
      return undef;
  }
  
  
  sub do_queued_async_reads {
      while (@read_queue) {
          shift(@read_queue)->();
      }
  }
  
  
  
  
  
  
  # put the terminal in cooked mode   (and make sure it gets changed back before the program exits)
  use POSIX qw(:termios_h);
  sub cooked_mode {
      $|++;
  
      ## cooked mode, echo off
      #Term::ReadKey::ReadMode(2);
  
      #system 'stty', '-icanon', '-echo', 'eol', "\001";
  
      # from PerlFAQ8
      my $term = POSIX::Termios->new();
      $term->getattr(0);
      our $orig_lflag = $term->getlflag();
      $term->setlflag($orig_lflag & ~(ECHO | ECHOK | ICANON));
      $term->setcc(VTIME, 1);
      $term->setattr(0, TCSANOW);
  
  
      eval q{
          END {
              ## reset tty mode before exiting
              #Term::ReadKey::ReadMode(0);         
  
              #system 'stty', 'icanon', 'echo', 'eol', chr(0);
  
              # from PerlFAQ8
              my $term = POSIX::Termios->new();
              $term->getattr(0);
              $term->setlflag($orig_lflag);
              $term->setcc(VTIME, 0);
              $term->setattr(0, TCSANOW);
          }
      };
      die $@ if $@;
  }
  
  
  sub output {
      my $all = join "", @_;
      if ($DEBUG && $all ne "\r" && $all ne "\n" && $all ne "\r\e[K") {
          print $debug_fh "    sending: ", ansi_escape($all), "\n";
      }
      print STDERR $all;
  }
  
  
  # Gets an ANSI response, reading only as many characters as necessary, and waiting only as long
  # as necessary.
  #
  # $timeout
  #       Seconds to wait for a reply.  Use 0 for no timeout.
  #
  # $response_end_character
  #       If we see this character, we know the response is finished.
  #
  #       Special values:
  #           - empty string -- means "read one buffer's worth of data".
  #           - undef -- means "there is no specific end-character...  read until timeout
  #           - regexp reference -- match several characters, not just one
  #                   (use the "qr" quote-like operator)
  sub read_ansi_reply {
      my ($timeout,
          $response_end_character) = @_;
  
      $timeout = 1.0 unless defined($timeout);
  
      my $reply = '';
      $@ = "";
      eval {
          local $SIG{ALRM} = sub { die "alarm\n" };
          alarm($timeout)     if ($timeout != 0);
  
          if (defined($response_end_character) && $response_end_character eq '') {
              # an empty-string means "read everything that's in the buffer"...  this assumes that
              # the response will be sent all-at-once, and that there will be a slight timegap in between
              # the response and anything else the terminal sends to us
              my $numchars = sysread(STDIN, $reply, 1024);
              $reply = substr($reply, 0, $numchars);
          } else {
              while (1) {
                  if (defined(my $c = getc())) {
                      #print ".";
                      $reply .= $c;
                      if (defined($response_end_character)) {
                          if (ref($response_end_character) eq 'Regexp') {
                              last if ($reply =~ $response_end_character);
                          } else {
                              last if ($c eq $response_end_character);
                          }
                      }
                  }
              }
          }
      };
      die $@ if ($@ && $@ ne "alarm\n");
      alarm 0;
      if ($DEBUG) {
          if ($@ eq "alarm\n" && (!defined($reply) || length($reply) == 0)) {
              print $debug_fh "    timeout\n";
          } else {
              print $debug_fh "    read response:  ", ansi_escape($reply), "\n";
          }
      }
      return $reply;
  }
  
  
  sub ansi_escape { map {(my $a = $_);
          $a =~ s/\\/\\\\/g;
          $a =~ s/\e/\\E/g;
          $a =~ s/\x5/\\5/g;
          $a =~ s/\x9B/\\x9B/g;
          $a =~ s/([\x00-\x1f\x7f-\xff])/"\\x" . sprintf "%02X", ord($1)/ge;
          $a} @_ }
  
  ##########################################################################################
  #####################################[ debugging ]########################################
  ##########################################################################################
              # this code should maybe be split off into its own package?
  
  # public method -- used by other modules to print to the debug log
  sub debug_log {
      if ($DEBUG) {
          # add extra delay in between each test
          select undef, undef, undef, $EXTRA_DELAY;
  
          print $debug_fh @_;
      }
  }
  
  
  sub debug__open_log {
      if ($DEBUG) {
          open $debug_fh, '>', '/var/tmp/termdetect.debug'        or die $!;
          print $debug_fh "\n" x 10;
  
          # autoflush
          my $prev_fh = select $debug_fh;
          $| = 1;
          select $prev_fh;
      } else {
          open $debug_fh, '>', '/dev/null';
      }
  }
  
  
  END {
      if ($DEBUG) {
          # indicate that the program is finished
          print $debug_fh "-"x80, "\n";
      }
  }
  
  
  
  
  1;
  
  
  # Copyright (C) 2012  Dee Newcum
  # https://github.com/DeeNewcum/
  #
  # You may redistribute this program and/or modify it under the terms of the GNU
  # General Public License as published by the Free Software Foundation; either
  # version 2 of the License, or (at your option) any later version.
TERMDETECT_IO

$fatpacked{"Termdetect_Match.pm"} = <<'TERMDETECT_MATCH';
  # After all the tests are run on the terminal, this module does the work of trying to find out
  # which database entry (or if things go badly: entries) match the test results most closely.
  
  
  package Termdetect_Match;
  
      use strict;
      use warnings;
  
      use Terminfo_Parser;
      use Termdetect_Tests;
  
      use Data::Dumper;
  
      use Exporter 'import';
  
      our @EXPORT = qw( match_results );
  
      use constant DEBUG_MATCHES => 1;
  
  
  # returns the name of the $TERM that best matches
  sub match_results {
      my ($test_results,              # the results from running all the tests on the current terminal
          $termmatch_db,              # the contents of "termmatch.src"
          $die_if_not_one,            # should we error out when there are more than one matches, or
                                      #           zero matches?   (optional param, defaults to yes)
              ) = @_;
  
      $die_if_not_one = 1        if (!defined($die_if_not_one));
  
      my $match_stats = calculate_match_statistics($test_results, $termmatch_db);
          #print Dumper $match_stats;
  
  
      my @no_mismatches;      # list of all terminals that had zero mismatches, and at least one match
      my $highest_match;
      my $highest_match_numyes = 0;
      while (my ($term, $stats) = each %$match_stats) {
          if (!exists $stats->{n} && defined($stats->{y})) {
              push @no_mismatches, $term;
              if ($stats->{y} > $highest_match_numyes) {
                  $highest_match_numyes = $stats->{y};
                  $highest_match = $term;
              }
          }
      }
  
      #show_match_percentages($match_stats, 3);       exit;
  
      if (@no_mismatches > 1) {
          if ($die_if_not_one) {
              print STDERR "Error: Multiple terminals matched: ",
                          join(", ", @no_mismatches), "\n";
              print STDERR "\n\nIt would help out greatly if you could submit data about this.\n";
              print STDERR "See       termdetect --help-submit\n";
              exit 1;
          } else {
              print STDERR "Error: Multiple terminals matched: ",
                          join(", ", @no_mismatches), "\n\n";
          }
      } elsif (@no_mismatches == 0) {
          if ($die_if_not_one) {
              print STDERR "Error: No terminals matched exactly.  Terminals that were close:\n";
              my $closest_match = show_match_percentages($match_stats, 5);
              print STDERR "\nRun this for more info:\n    $0 --check=$closest_match\n";
              print STDERR "\n\nIt would help out greatly if you could submit data about this.\n";
              print STDERR "See       termdetect --help-submit\n";
              exit 1;
          }
      } elsif (@no_mismatches == 1) {
          Termdetect_Tests::calculate_derived_values_after_match($test_results, $termmatch_db, $highest_match);
      }
  
      return $highest_match;
  }
  
  
  # show the list of terminals, ordered by match percentage
  sub show_match_percentages {
      my ($match_stats, $limit_to) = @_;
              # $limit_to -- the number of items to display;   undef for unlimited
  
      my @match_percentage;       # list all terminals, sorted in order of match percentage
      foreach my $stats (values %$match_stats) {
          next unless ($stats->{total});          # we need a non-zero denominator
          $stats->{percentage} = int(100 * ($stats->{y} || 0) / $stats->{total});
      }
      @match_percentage = sort { $match_stats->{$b}{percentage} <=> $match_stats->{$a}{percentage} }
                               keys %$match_stats;
          #print Dumper \@match_percentage;    exit;
  
      my $ctr = 0;
      foreach my $term (@match_percentage) {
          printf STDERR "    %-15s  %3d%% match\n",
                        $term,
                        $match_stats->{$term}{percentage};
          $ctr++;
          last if (defined($limit_to) && $ctr >= $limit_to);
      }
  
      # return the terminal with the closest match
      return $match_percentage[0];
  }
  
  
  sub calculate_match_statistics {
      my ($test_results,              # the results from running all the tests on the current terminal
          $termmatch_db               # the contents of "termmatch.src"
              ) = @_;
  
      #print ansi_escape_no_nl(Dumper $test_results);      exit;
      #print ansi_escape_no_nl(Dumper $termmatch_db);      exit;
      
      my %pass_fail_count;
  
      foreach my $termmatch_entry (values %$termmatch_db) {
          my $termname = $termmatch_entry->{termnames}[0];
  
          next if (exists $termmatch_entry->{alias});     # skip aliases, we'll only process canonical names
  
          my $check_this = (exists $::ARGV{check} &&
                  ($::ARGV{check} eq '1' || $::ARGV{check} eq $termname));
  
          print "========[ $termname ]========\n"         if $check_this;
          #while (my ($cap, $test_result) = each %$test_results) {
          foreach my $cap (sort keys %$test_results) {
              my $test_result = $test_results->{$cap};
  
              next if ($cap =~ /^c_/);
              next if ($Termdetect_Tests::rarely_tested_synthetics{$cap} &&
                          !exists $termmatch_entry->{fields}{$cap});
              
              printf "\t%-20s  ", $cap            if $check_this;
              $pass_fail_count{$termname}{total}++;
              if (exists $termmatch_entry->{fields}{$cap}) {
                  my $yn = match_one_field($test_result, $termmatch_entry->{fields}{$cap});
                  if ($yn) {
                      print "match\n"         if $check_this;
                  } else {
                      printf "MISMATCH -- got: %-25s  wanted: %s\n",
                              quote(summarize_result($test_result)), 
                              quote(ansi_escape($termmatch_entry->{fields}{$cap}{assign}))
                                  if $check_this;
                  }
                  $pass_fail_count{$termname}{$yn ? 'y' : 'n'} ++;
              } else {
                  print "NOT PRESENT -- got: ", quote(summarize_result($test_result)), "\n"
                          if $check_this;
                  $pass_fail_count{$termname}{u} ++;      # "U" = unspecified
              }
          }
          print "\n"          if $check_this;
      }
      return \%pass_fail_count;
  }
  
          # returns the input, but surrounded in quotes
          sub quote {
              return '"' . join("", @_) . '"';
          }
  
  
  # Match one test-result against a capability in one termmatch entry.
  # Returns true/false, regarding whether it matched.
  sub match_one_field {
      my ($test_result, $entry_cap) = @_;
  
      #print ansi_escape_no_nl(Dumper $entry_cap); exit;
  
      if (exists $entry_cap->{assign} && exists $test_result->{received}) {
          if ($entry_cap->{assign} !~ /\%/) {
              return ($test_result->{received} eq $entry_cap->{assign});
          } else {
              my @f = split /(\%[xy][-+]\d|\%[^xy])/, $entry_cap->{assign};
              my $pat = '';
              my ($pat_x_delta, $pat_y_delta);
              foreach my $f (@f) {
                  if ($f eq '%*') {
                      $pat .= ".*";
                  } elsif ($f eq '%+') {
                      $pat .= ".+";
                  } elsif ($f eq '%%') {
                      $pat .= '%';                # just the character '%'
                  } elsif ($f =~ /^\%([xy])([-+]\d)$/) {
                      if ($1 eq 'x') {
                          $pat_x_delta = int($2);
                      } elsif ($1 eq 'y') {
                          $pat_y_delta = int($2);
                      }
                  } elsif ($f =~ /^\%(.)$/) {
                      $pat .= quotemeta($1);      # an unsupported percent-char
                  } else {
                      $pat .= quotemeta($f);
                  }
              }
              # both the delta-x and delta-y MUST be acknowledged, or it isn't a match
              return 0     unless (($pat_x_delta || 0) == ($test_result->{x_delta} || 0)
                               &&  ($pat_y_delta || 0) == ($test_result->{y_delta} || 0));
              return ($test_result->{received} =~ /^$pat$/);
          }
      }
  }
  
  
  
  
  
  
  
  1;
  
  # Copyright (C) 2012  Dee Newcum
  # https://github.com/DeeNewcum/
  #
  # You may redistribute this program and/or modify it under the terms of the GNU
  # General Public License as published by the Free Software Foundation; either
  # version 2 of the License, or (at your option) any later version.
TERMDETECT_MATCH

$fatpacked{"Termdetect_Tests.pm"} = <<'TERMDETECT_TESTS';
  # This module directly performs terminal-type tests on the terminal.
  # Routines that deal only with the test RESULTS are located elsewhere.
  # (also, tests that are encoding-specific are located in Termdetect_Encoding.pm)
  
  
  package Termdetect_Tests;
  
      use strict;
      use warnings;
  
      use Termdetect_Encoding;
      use Termdetect_IO;
  
      use Data::Dumper;
  
      use Exporter 'import';
  
      our @EXPORT = qw( perform_all_tests ansi_escape_no_nl ansi_escape summarize_result );
  
      
      # synthetic capabilities that are rarely tested against
      our %rarely_tested_synthetics = map {$_ => 1} qw(
              s_font_size
              s_screen_size
              s_window_icon_label
              s_window_size
              s_window_pos
              s_window_title
              s_encoding
          );
  
  
  
  
  # returns a data structure with the results of running the tests
  sub perform_all_tests {
      cooked_mode();
  
      ensure_cursor_position_supported();
      
      local our %all_results;     # this needs to be visible inside run_and_store_tests()
  
      run_and_store_test(r_device_status      => "\e[5n");
      run_and_store_test(r_printer_status     => "\e[?15n");
      run_and_store_test(r_term_id            => "\eZ");
      run_and_store_test(r_device_attr        => "\e[c");
      run_and_store_test(r_device_attr2       => "\e[>c");
      run_and_store_test(r_device_attr3       => "\e[=c");
      run_test("\e[=1c");         # some terminals interpret DA3 as a request to turn off the cursor, so we need to turn it back on
      run_and_store_test(r_term_param         => "\e[x");
      run_and_store_test(r_enquiry            => "\5");
  
      run_and_store_test(r_ext_cursor_pos     => "\e[?6n");
      run_and_store_test(r_window_title       => "\e[21t");
      run_and_store_test(r_window_icon_label  => "\e[20t");
      run_and_store_test(r_window_size_px     => "\e[14t");
      run_and_store_test(r_window_size_char   => "\e[18t");
      run_and_store_test(r_window_state       => "\e[11t");
      run_and_store_test(r_window_pos         => "\e[13t");
      run_and_store_test(r_screen_size        => "\e[19t");
  
      run_and_store_test(m_c1                 => "\x9B0K");
      run_and_store_test(m_pad_null           => "\x00");
      run_and_store_test(m_null_inside        => "\e\x00K");
      run_and_store_test(m_cancel             => "\e[?\x18");
      run_and_store_test(m_sub                => "\e[?\x1A");
      run_and_store_test(m_esc                => "\e[?\eK");
  
      synthetic__ff_clears();
  
      Termdetect_Encoding::do_encoding_tests(\%all_results);
  
  
      if (0) {
          ################# things that haven't been given a test_id yet ###############
          read_phase {
              print "="x30, "[ r_* tests ]", "="x30, "\n";        };
  
          #run_and_display_test("\x9B5n",              "C1 version of DSR");
          run_and_display_test("\e[?50n",             "DSR - keyboard status");
          run_and_display_test("\e[?20n",             "DSR - user-defined key status");
  
          read_phase {
              print "="x30, "[ m_* tests ]", "="x30, "\n";        };
  
          run_and_display_test("\e[=",                "application keypad mode");
          run_and_display_test("\e[>",                "numeric keypad mode");
          run_and_display_test("\e|",                 "visual bell");
          run_and_display_test("\e[7",                "save cursor and attributes");
          run_and_display_test("\eg",                 "visual bell");
          run_and_display_test("\eP\e\\",             "DCS - device control string (blank)");
          run_and_display_test("\eP\e[0m\e\\",        "DCS - device control string (SGR reset); must be non-zero to pass");
          run_and_display_test("\e\%G",               "[ISO2022] select UTF8 character set");
          run_and_display_test("\e*C",                "[ISO2022] designate G2 character set");
          run_and_display_test("\e+C",                "[ISO2022] designate G3 character set");
          run_and_display_test("\e\\",                qq{"do nothing" sequence});
  
  
          read_phase {
              print "="x30, "[ s_* tests ]", "="x30, "\n";        };
  
          run_and_display_test("\ek-\e\\",            "set title");
          run_and_display_test("\ek-\e\\\e[21t",      "set + get title");
  
          read_phase {        print "\n\n"      };
      }
  
      do_queued_async_reads();
      output("\r\e[K");     # erase the line that we just sprayed gibberish over
  
      calculate_derived_values(\%all_results);
  
      return \%all_results;
  }
  
  
  ##########################################################################################
  ##################################[ synthetic tests ]#####################################
  ##########################################################################################
  
  
  # s_ff_clears -- does the form-feed character (^L) clear the screen?
  #
  # NOTE however, that some terminals will respond to FF by clearing the screen, but NOT moving the
  #       cursor back to (1,1).  What we're REALLY detecting here is moving the cursor back to
  #       (1,1), *not* whether the screen is cleared.
  #
  #       See:  http://www.aivosto.com/vbtips/control-characters.html#FF
  sub synthetic__ff_clears {
      return if ($::ARGV{'nose'});        # side effect: clears the screen
  
      DEBUG_test_name();
  
      output("\r\e[K");           # clear any gibberish that might be on this line, since we're dropping down a line
      output("\n");               # move a line first, to make sure we're not on the top line
      run_test("\x0c",
          sub {
              my ($test_result) = @_;
              our %all_results;           # pull this in from the 'local'ized copy in perform_all_tests()
  
              # did we move up one or more lines?
              $all_results{s_ff_clears}{received} =
                      (($test_result->{y_delta} || 0) < 0) ? 'true' : 'false';
  
              if ($all_results{s_ff_clears}{received} eq 'false') {
                  # if the screen wasn't cleared, move back up one line
                  output("\r\e[K"         # clear current line
                       . "\e[A");         # move up one line
              }
          });
  }
  
  
  ##########################################################################################
  ##################################[ standard tests ]######################################
  ##########################################################################################
  
  # We use the cursor-position report a lot...   if that doesn't work, then things will get hung up
  # and take way too long.
  # Figure this out before we waste a lot of time.
  sub ensure_cursor_position_supported {
  
      DEBUG_test_name();
  
      output("\e[6n");
  
      read_phase {
          my $reply = read_ansi_reply(1.0, qr/\e[^a-zA-Z]*[a-zA-Z]/);
          if (!defined($reply) || $reply !~ /\e\[\d+;\d+R$/s) {
              close STDOUT; select undef,undef,undef,0.001;
              die "Terminal is unable to report the cursor position.  This is required for many tests.\n";
          }
      };
  }
  
  
  sub run_and_store_test {
      my ($test_id, $sequence) = @_;
  
      DEBUG_test_name($test_id);
  
      run_test($sequence, sub {
          my ($test_result) = @_;
          our %all_results;           # pull this in from the 'local'ized copy in perform_all_tests()
          $all_results{$test_id} = $test_result;
      });
  }
  
  
  sub run_and_display_test {
      my ($sequence) = shift;
      my $test_id = '';
      $test_id = shift    if (@_ >= 2);
      my $description = shift;
  
  
      run_test($sequence, sub {
          my ($test_result) = @_;
          print "\r";
          my $response = '';
          if ($test_result->{x_delta}) {
              $response = "[+$test_result->{x_delta}]";
          } else {
              $response = $test_result->{received};
          }
          printf  "%-20s  %-15s %-25s   %s\n",
                  $test_id,
                  ansi_escape($sequence),
                  ansi_escape($response),
                  $description;
      });
  }
  
  
  ##########################################################################################
  ##################################[ derived values ]######################################
  ##########################################################################################
  
  # some values are purely derived from others...  these don't require any I/O, and can be done after
  # the last call to do_queued_async_reads()
  sub calculate_derived_values {
      my ($all_results) = @_;
  
      if ($all_results->{r_window_size_char}{received}) {
          my (undef, $ch_y, $ch_x) = ansi_params($all_results->{r_window_size_char}{received});
          $all_results->{s_window_size}{received} = "$ch_x x $ch_y";
      }
      my ($fontsize_x, $fontsize_y);
      if ($all_results->{r_window_size_px}{received} && $all_results->{r_window_size_char}{received}) {
          my (undef, $px_y, $px_x) = ansi_params($all_results->{r_window_size_px}{received});
          my (undef, $ch_y, $ch_x) = ansi_params($all_results->{r_window_size_char}{received});
          #print Dumper [$ch_x, $ch_y];
          $fontsize_x = int($px_x / $ch_x);
          $fontsize_y = int($px_y / $ch_y);
          $all_results->{s_font_size}{received} = "$fontsize_x x $fontsize_y";
      }
      if ($all_results->{r_window_size_px}{received} && $all_results->{r_window_size_char}{received} &&
              $all_results->{r_screen_size}{received}) {
          my (undef, $s_y, $s_x) = ansi_params($all_results->{r_screen_size}{received});
          $s_x *= $fontsize_x;
          $s_y *= $fontsize_y;
          # We have a quandary here -- the screen-size we derived isn't EXACTLY right.
          # It could be off by as much as +/- $fontsize_x and $fontsize_y.
          #
          # One solution is just to round to the nearest N, where N is:
          #       8 for X         
          #       4 for Y
          # based on the greatest-common-factor for resolution widths and heights.
          $s_x = round_up($s_x, 8);
          $s_y = round_up($s_y, 4);
          $all_results->{s_screen_size}{received} = "$s_x x $s_y";
      }
      if ($all_results->{r_window_pos}{received}) {
          my (undef, $p_x, $p_y) = ansi_params($all_results->{r_window_pos}{received});
                      # ^^^^^^ is this backwards?  This is what libVTE uses, but it seems backwards.
          $all_results->{s_window_pos}{received} = "$p_x x $p_y";
      }
      if (($all_results->{r_window_title}{received} || '') =~ /^\e\]l(.*)\e\\$/) {
          $all_results->{s_window_title}{received} = $1;
      }
      if (($all_results->{r_window_icon_label}{received} || '') =~ /^\e\]L(.*)\e\\$/) {
          $all_results->{s_window_icon_label}{received} = $1;
      }
  }
  
  sub calculate_derived_values_after_match {
      my ($all_results, $termmatch_db, $matched_term) = @_;
  
      calculate_version($all_results, $matched_term);
  }
  
  
  sub calculate_version {
      my ($all_results, $matched_term) = @_;
  
      return unless (exists $all_results->{r_device_attr2});
      my (undef, $da2) = split /;/, $all_results->{r_device_attr2}{received};
  
      # The exact interpretation of the second argument of DA2 varies based on terminal.
      # This is the only place in the code that we have terminal-specific code.  This really
      # out to be moved to termmatch.src in some way.
      if ($matched_term eq 'vte') {
          $da2 =~ s/(\d\d)$//;
          my $last2digits = $1;
          $all_results->{s_term_version}{received} = sprintf "libvte v%0.2f.%d", $da2 / 100, $last2digits;
      } elsif ($matched_term =~ /^screen(?:_.*)?$/) {
          $da2 =~ s/(\d\d)$//;
          my $last2digits = $1;
          $all_results->{s_term_version}{received} = sprintf "v%0.2f.%02d", $da2 / 100, $last2digits;
      } elsif ($matched_term eq 'mrxvt') {
          # mrxvt's version number already has dots in it, which is a total violation of the spec
          $all_results->{s_term_version}{received} = "v$da2";     
      } elsif ($matched_term eq 'xterm') {
          $all_results->{s_term_version}{received} = "#$da2";
      } else {
          # otherwise, the version usually just means "we are feature-compatible with version XX of xterm"
      }
  }
  
  
      sub round_up {
          my ($n, $modulo) = @_;
          if ($n % $modulo) {
              $n += ($modulo - $n % $modulo);
          }
          return $n;
      }
  
  
  # given the {received} field, return the numeric parameters, as an array
  sub ansi_params {
      my ($received) = @_;
      return () unless defined($received);
      my @params = ($received =~ /(\d+)/g);
      return @params;
  }
  
  
  ##########################################################################################
  ############################[ debugging and human-readable ]##############################
  ##########################################################################################
  
  # when $Termdetect_IO::DEBUG is turned on, print out the provided test summary, before running
  # the test
  sub DEBUG_test_name {
      if ($Termdetect_IO::DEBUG) {
          if (!@_) {
              # if no name is given, use the caller's subroutine name
              my $caller_sub = (caller(1))[3];
              $caller_sub =~ s/^.*:://;
              @_ = ($caller_sub);
          }
          debug_log("test ", @_, "\n");
      }
  }
  
  
  sub summarize_result {
      my ($test_result) = @_;
      #print ansi_escape_no_nl(Dumper $test_result); exit;
      if (exists $test_result->{x_delta}) {
          return "%x+$test_result->{x_delta}";
      } else {
          return (ansi_escape($test_result->{received}))[0];
      }
  }
  
  
  sub debug_show_remaining_input {
      print "---- debug_show_remaining_input ----\n";
      while (my $reply = read_ansi_reply(0, '')) {
          print ansi_escape($reply), "\n";
      }
      exit;
  }
  
  
  sub ansi_escape { map {(my $a = $_);
          $a =~ s/\\/\\\\/g;
          $a =~ s/\e/\\E/g;
          $a =~ s/\x5/\\5/g;
          $a =~ s/\x9B/\\x9B/g;
          $a =~ s/([\x00-\x1f])/"\\x" . sprintf "%02X", ord($1)/ge;
          $a} @_ }
  
  
  # like ansi_escape, but don't escape newlines
  sub ansi_escape_no_nl {
      my $text = join('', @_);
      my @lines = split /[\n\r]+/, $text;
      @lines = map {ansi_escape($_)} @lines;
      return join("\n", @lines), "\n";
  }
  
  
  
  
  
  1;
  
  
  # Copyright (C) 2012  Dee Newcum
  # https://github.com/DeeNewcum/
  #
  # You may redistribute this program and/or modify it under the terms of the GNU
  # General Public License as published by the Free Software Foundation; either
  # version 2 of the License, or (at your option) any later version.
TERMDETECT_TESTS

$fatpacked{"Terminfo_Parser.pm"} = <<'TERMINFO_PARSER';
  # A Perl implemntation of a terminfo source parser.
  #
  # See the unit tests in parser/parser_unit_test -- we tested this somewhat well against the
  # original tic(1) parser.
  
  
  package Terminfo_Parser;
  
      use strict;
      use warnings;
  
      use Exporter 'import';
  
      our @EXPORT = qw( parse_terminfo ti_dump_terminal );
  
  
  # terminfo(5) says of terminfo's syntax:
  #
  #      Entries  in  terminfo  consist  of  a  sequence of "," separated fields
  #      (embedded commas may be escaped with a backslash or notated  as  \054).
  #      White  space  after  the "," separator is ignored.  The first entry for
  #      each terminal gives the names which are known for the  terminal,  sepa-
  #      rated  by  "|"  characters.   The  first  name given is the most common
  #      abbreviation for the terminal, the last name given  should  be  a  long
  #      name  fully  identifying the terminal, and all others are understood as
  #      synonyms for the terminal name.  All names but the last  should  be  in
  #      lower  case and contain no blanks; the last name may well contain upper
  #      case and blanks for readability.
  #
  #      A  number  of  escape  sequences   are  provided  in  the  string valued
  #      capabilities for easy encoding of characters there.  Both \E and \e map
  #      to  an  ESCAPE character, ^x maps to a control-x for any appropriate x,
  #      and the sequences \n \l \r \t \b  \f  \s  give  a  newline,  line-feed,
  #      return, tab, backspace, form-feed, and space.  Other escapes include \^
  #      for ^, \\ for \, \, for comma, \: for :, and \0  for  null.   (\0  will
  #      produce  \200,  which does not terminate a string but behaves as a null
  #      character on most terminals, providing CS7 is specified.  See stty(1).)
  #      Finally, characters may be given as three octal digits after a \.
  
  #      ...
  #
  #      Sometimes  individual  capabilities must be commented out.  To do this,
  #      put a period before the capability name.  For example, see  the  second
  #      ind in the example above.
  
  #      ...
  #
  #      Numeric  capabilities are followed by the character "#" and then a
  #      positive value.
  
  #      ...
  #
  #      String valued capabilities, such as el (clear to end of line sequence)
  #      are given by the two-character code, an "=", and then a string ending
  #      at the next following ",".
  #       
  #      ...
  #
  #      The % encodings have the following meanings:
  #               (read terminfo(5) for full info about % encodings)
  #
  # The Single UNIX Specification further says:
  #
  #      Each description consists of a header (beginning in column 1) and one
  #      or more lines that list the features for that particular device. Every
  #      line in a terminfo source file must end in a comma. Every line in a
  #      terminfo source file except the header must be indented with one or
  #      more white spaces (either spaces or tabs).
  #
  #      Entries in terminfo source files consist of a number of
  #      comma-separated fields. White space after each comma is ignored. 
  #
  
  sub parse_terminfo  {
      my ($lines) = @_;
      return flatten_terminfo(_parse_terminfo($lines));
  }
  
  
  sub _parse_terminfo  {
      my ($lines) = @_;
  
      my @parsed;
  
      my @lines = split /\n/, $lines;
      our @process_fields;
      for (our $lineno=0; $lineno<@lines; $lineno++) {
          our %field = (lineno => $lineno);
          our @fields = ();
          our $is_continuation = 1;
          $lines[$lineno] =~ m{
                ^ \# .*           # ignore comment lines
              | ^ \s* $           # ignore blank lines
              | ^( \s* )
                                      (?{ $is_continuation = length $^N    })
                  (?:
                      (?! \s )
                      ((?:  \\\d\d\d  |  [\\^][^\n]  |  [^,\\^\n=\#]  )+)
                         #  ^^^^^^^^     ^^^^^^^^     ^^^^^^^^^^^    various escape codes
                                      (?{ local $field{capability} = $^N   })
                      (?:     = ((?:  \\\d\d\d  |  [\\^][^\n]  |  [^,\\^\n]  )*)
                                ## same as above, but with [=\#] removed, and + changed to *
                                      (?{ local $field{assign} = $^N    })
                           | \# (\d+)
                                      (?{ local $field{num} = $^N    })
                           )?
                      , \s*  
                                      (?{ push(@fields, {%field})   })
                  )+ $
          }x
              or die "syntax error on line " . ($lineno+1) . "\n\t$lines[$lineno]\n";
  
          if (defined($is_continuation)) {
              if ($is_continuation) {
                  push(@process_fields, @fields);
              } else {
                  push(@parsed, process_fields(@process_fields)) if (@process_fields);
                  @process_fields = (@fields);
              }
          }
      }
      push(@parsed, process_fields(@process_fields)) if (@process_fields);
  
      return \@parsed;
  }
  
  
  sub process_fields {
      my @fields = @_;
  
      my $termfield = shift @fields;
  
      my @termnames = split /\|/, $termfield->{capability};
      my $descr = pop @termnames      if (@termnames >= 2);
      my %parsed = (
          termnames      => \@termnames,
          term_descr     => $descr,
          lineno_range   => [         # range of line numbers that this entry occupies
                  $termfield->{lineno},       # first line
                  $fields[-1]{lineno},        # last line
              ],
          );
  
      $parsed{fields} = [
              map {
                  $_->{assign} = terminfo_unescape($_->{assign})      if $_->{assign};
                  $_
              } @fields
          ];
  
      return \%parsed;
  }
  
  
  BEGIN {
      our %escapes = (
  
          "\\a"  => "\x07",   # bell
          "\\b"  => "\x08",   # backspace
          "\\f"  => "\x0c",   # form feed
          "\\e"  => "\e",     # escape
          "\\l"  => "\x0a",   # line feed
          "\\n"  => "\x0a",   # newline
          "\\r"  => "\x0d",   # return
          "\\s"  => " ",      # space
          "\\t"  => "\t",     # horizontal tab
          "\\0"  => "\200",   # null   (see detailed info about this in terminfo(5)...   it's not clear to me why we use \200 instead of \x00)
  
          "^\\"  => "\x1c",
          "^]"   => "\x1d",
          "^^"   => "\x1e",
          "^_"   => "\x1f",
  
          # plain escapes
          "\\,"  => ",",
          "\\:"  => ":",
          "\\\\" => "\\",
          "\\^"  => "^",
      );
      for ('a'..'z') {
          $escapes{"^$_"} = chr(ord($_) - 96);
      }
      #print Dumper \%escapes; exit;
  
  
  # The output of this should EXACTLY match tigetstr(3).
  # That is -- the percent parameters haven't been expanded (it doesn't do what tparm() does), but
  # all other escape-codes should be expanded.
  sub terminfo_unescape {
      local $_ = shift;
  
      s/
          \\(\d\d\d)    |
          (\%)(?=\\)    |         # i have no clue what the fuck this is...  but this is required to match the official parser's behavior
          ([\\^].)      |
          \%{(\d\d+)}   |
          \%'([^']+)'   |
          (%'[^']+'|%.)
      /
              defined($1) ? chr(oct($1))
            : defined($2) ? $2
            : defined($3) ? ($escapes{lc $3} || substr($3, -1))
            : defined($4) ? unescape_percent_char($4)
            : defined($5) ? ("%'" . terminfo_unescape($5) . "'")
            : defined($6) ? $6 : "YOUBROKEIT"
          /gex;
      return $_;
  }
  }
  
      sub unescape_percent_char {
          my $charnum = shift;
          if ($charnum >= 32 && $charnum <= 126 && $charnum != 92) {
              return "\%'" . chr($charnum) . "'";
          } else {
              return "\%{$charnum}";
          }
      }
  
  
  # The terminfo specification allows for use= clauses (and @ items to cancel things inside uses).
  # This takes the parsed fields that contain use= clauses, and flattens everything out so you don't
  # have to do a lot of work to find out what the final values for a given $TERM are.
  sub flatten_terminfo {
      my ($parsed) = @_;
  
      ## gather up all aliases
      my %canonical_name;     # mapping from   canonical_name => entry_structure
      my %all_term_names;     # mapping from   alias => canonical_name
      foreach my $entry (@$parsed) {
          my $canonical = $entry->{termnames}[0];
  
          $canonical_name{$canonical} = $entry;
          foreach my $termname (@{$entry->{termnames}}) {
              $all_term_names{$termname} = $canonical;
          }
      }
  
      ## gather up all "use" entries
      my %first_level_uses;
      foreach my $entry (@$parsed) {
          my $canonical = $entry->{termnames}[0];
          foreach my $field (@{$entry->{fields}}) {
              if ($field->{capability} eq 'use') {
                  push @{$first_level_uses{$canonical}}, $field->{assign};
              }
          }
      }
  
      ## now, merge all the capabilities in the proper precedence order
      my %flattened;
      foreach my $canonical (keys %canonical_name) {
          # recursively explore the tree
          my $merged = merge_tree($canonical,
                                  {},
                                  \%canonical_name,
                                  \%all_term_names,
                                  \%first_level_uses,
                                  $canonical);
  
          # actually delete all entries that are explicitely marked "deleted"
          while (my ($cap, $field) = each %$merged) {
              delete $merged->{$cap} if (!defined($field));
          }
  
          $flattened{$canonical} = {
              %{$canonical_name{$canonical}},
              fields => $merged,
          };
      }
      #return \%flattened;
                  
      ## add aliases
      while (my ($alias, $canonical) = each %all_term_names) {
          if (!exists $flattened{$alias}) {
              $flattened{$alias} = {
                  alias => $canonical,
                  termnames => [$alias],      # $flattened{$canonical}{termnames},
              };
          }
      }
  
      return \%flattened;
  }
  
  
  
  # recursively explore the tree, merging the fields for a specific entry
  #       %$terms_seen gets built from top-down
  #       %$merged gets built from bottom-up
  sub merge_tree {
      my ($term,                  # the specific terminal to return the list of merged fields for
          $terms_seen,            # all terminals seen so far, when exploring the tree
                                  #           (note: this lists ONLY the parent nodes, in direct
                                  #           lineage...  it does NOT list siblings of parents)
          @passthru) = @_;
  
      my ($canonical_name,        # mapping from   canonical_name => entry_structure
          $all_term_names,        # mapping from   alias => canonical_name
          $first_level_uses,      # mapping from   canonical_name => ordered list of "use" entries for this level ONLY
          $orig_term,             # the $term from the first-level call to this
          ) = @passthru;
  
      #$num_dependencies{$orig_term}++;
  
      # according to terminfo(5):
      #           "The capabilities given before use override those in the base type named by use.
      #           If there are multiple use capabilities, they are merged in reverse order.
      #           That is, the rightmost use reference is processed first, then the one to its
      #           left, and so forth.  Capabilities given explicitly in the entry override
      #           those brought in by use references."
      my $merged = {};
      my %terms_seen = (%$terms_seen, $term => 1);
      foreach my $use (reverse @{$first_level_uses->{$term} || []}) {
          if (! exists $all_term_names->{$use}) {
              die "Terminal not found in line:    use=$use,\n";
          }
          $use = $all_term_names->{$use};         # canonicalize
          next if ($terms_seen{$use});            # avoid infinite loops
          my $subtree = merge_tree($use, \%terms_seen, @passthru);          # recursion step -- call ourselves
          $merged = merge_fields($merged, $subtree);
      }
      $merged = merge_fields($merged, 
                       field__list_to_hash(  $canonical_name->{$term}{fields}  ));
  
      return $merged;
  }
  
  
  # merge two sets of fields, with the "$a" one taking precedent over "$b"
  sub merge_fields {
      my $a = field__list_to_hash(shift);
      my $b = field__list_to_hash(shift);
  
      my %merged = %$a;
  
      while (my ($cap, $field) = each %$b) {
          if ($cap eq 'use') {
              next;       # we're handling the hierarchy elsewhere
          } elsif ($cap =~ s/\@$//) {
              delete $merged{$cap};
          } else {
              $merged{$cap} = $field;
          }
      }
      return \%merged;
  }
  
          # convert a list-ref of fields into a hash-ref of fields
          #       (or, if already a hash-ref...  just return it untouched)
          sub field__list_to_hash {
              my ($field_list) = @_;
              return $field_list  if ref($field_list) eq 'HASH';
              return {
                      map {$_->{capability} => $_}
                          @$field_list
                     };
          }
  
  
  
  
  #############################################################################
  ##############[ debugging only ]#############################################
  #############################################################################
  
  
  
  sub ti_dump_terminal {
      my @terms = sort {$a->{termnames}[0] cmp $b->{termnames}[0]} @_;
      my $return = '';
      foreach my $terminal (@terms) {
          $return .= "================[ " . join(" -- ", @{$terminal->{termnames}}, $terminal->{term_descr} || '') .
                      " ]================\n";
          if (exists $terminal->{alias}) {
              $return .= sprintf "%20s   %s\n\n", "alias of", $terminal->{alias};
              next;
          }
  
          my $fields = $terminal->{fields};
          if (ref($fields) eq 'HASH') {
              $fields = [ sort { ti_dump_sort_fields() } values %$fields ];
          }
          $return .= ti_dump_field(@$fields);
          $return .= "\n";
      }
      return $return;
  }
  
  
  sub ti_dump_field {
      my $return = '';
      foreach my $field (@_) {
          next if (!defined($field));
          $return .= sprintf "%20s", $field->{capability};
          if ($field->{assign}) {
              $return .= " = " . qquote($field->{assign}) . "\n";
          } elsif ($field->{num}) {
              $return .= " # " . qquote($field->{num}) . "\n";
          } elsif ($field->{deleted}) {
              $return .= " XXXXXXXXXXX deleted\n";
          } else {
              $return .= "\n";
          }
      }
      return $return;
  }
  
  
  sub ti_dump_sort_fields {
                          ti_field_type($a) cmp ti_field_type($b) ||
                          $a->{capability} cmp $b->{capability}
  }
  
  
  sub ti_field_type {
      my ($field) = @_;
      return "3assign" if ($field->{assign});
      return "2num" if ($field->{num});
      return "1bool";
  }
  
  
  sub qquote {my$q=Data::Dumper::qquote($_[0]);$q=~s/^"(.*)"$/$1/s;$q}
  
  1;
  
  
  
  # Copyright (C) 2012  Dee Newcum
  # https://github.com/DeeNewcum/
  #
  # You may redistribute this program and/or modify it under the terms of the GNU
  # General Public License as published by the Free Software Foundation; either
  # version 2 of the License, or (at your option) any later version.
TERMINFO_PARSER

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
#!/usr/bin/perl

# auto-detect which terminal emulator we're talking to
#
# https://github.com/DeeNewcum/termdetect


# Copyright (C) 2012  Dee Newcum
# https://github.com/DeeNewcum/
#       You may redistribute this program and/or modify it under the terms of the GNU General Public
#       License as published by the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.


    use strict;
    use warnings;

    # improved FindBin
    use Cwd 'abs_path';
    use File::Basename;
    use lib $FindBin::Bin = dirname( abs_path $0 );

    use Terminfo_Parser;
    use Termdetect_Tests;
    use Termdetect_Match;

    use Getopt::Long;
    use Data::Dumper;

    
    # constants
    use constant VERSION => "0.10";


our %ARGV;
process_cmdline();


my $termmatch_file = locate_termmatch_file();

## read in the termmatch database
my $termmatch_db = parse_terminfo(scalar(slurp($termmatch_file)));
    #print ti_dump_terminal(values %$termmatch_db);      exit;

## read in the test results from the current terminal
my $test_results = perform_all_tests();
    #print Dumper $test_results;     exit;
    #print ansi_escape_no_nl(Dumper $test_results);      exit;

## ... and match them together
my $term = match_results($test_results, $termmatch_db,
    !($ARGV{snapshot} || $ARGV{dump} || $ARGV{check}));



## generate the desired output
if ($ARGV{snapshot}) {
    show_snapshot($test_results);

} elsif ($ARGV{dump}) {
    # Does this overlap with --snapshot too much?  If so, then we'll get rid of this.
    foreach my $cap (sort keys %$test_results) {
        printf "%25s  %s\n", $cap, summarize_result($test_results->{$cap});
    }

} elsif ($ARGV{result}) {
    if (exists $test_results->{$ARGV{result}}) {
        print summarize_result($test_results->{$ARGV{result}}), "\n";
    }

} elsif (!$ARGV{check}) {
    if (defined($term)) {
        if ($ARGV{t}) {
            my $final_term = TERM_fallback($term, $termmatch_db);
            if ($final_term) {
                print "$final_term\n";
            } else {
               print STDERR "The suggested \$TERM \"$term\" wasn't found.\n";
                print STDERR "        \n";
                help_install_terminfos();
            }
        } else {
            my $all_aliases = join " / ", @{ $termmatch_db->{$term}{termnames}};
            my @fields = (
                    ['terminal',            $all_aliases],
                    ['version',             $test_results->{s_term_version}],
                    ['encoding',            $test_results->{s_encoding}],
                    ['terminal size',       $test_results->{s_window_size}],
                    ['font size',           $test_results->{s_font_size}],
                    ['window position',     $test_results->{s_window_pos}],
                    ['screen size',         $test_results->{s_screen_size}],
            );
            foreach my $field (@fields) {
                next unless defined($field->[1]);
                my $disp = $field->[1];
                if (ref($disp) eq 'HASH' && exists $disp->{received}) {
                    $disp = $disp->{received};
                }
                printf "%20s:   %s\n", $field->[0], $disp;
            }

            if (!does_terminfo_exist("vt100-putty")) {
                print "\nThe full set of terminfo entries haven't been installed,\n",
                        "see --help-terminfo for info on installing them.\n";
            }
        }
    } else {
        print STDERR "No \$TERM matched.  Run again with --check for more information.\n";
        print "$ENV{TERM}\n"        if ($ARGV{t});      # pass through the existing terminal
    }
}




sub process_cmdline {
    GetOptions( \%ARGV,
                    map {"$_:s"}        # all options have optional arguments, like Getopt::Casual
        "help|h|?",
        qw( check nose t snapshot result dump help-submit help-terminfo version ),
    ) or usage();
    %ARGV = map {length()?$_:1} %ARGV;      # arguments are optional
    $ARGV{help} and usage();
    $ARGV{'help-submit'} and help_submit();
    $ARGV{'help-terminfo'} and help_install_terminfos();
    if ($ARGV{version}) {
        print "termdetect, version ", VERSION, "\n";
        exit;
    }
}


sub usage {
    print STDERR <DATA>;
    exit;
}

sub help_submit {
    print STDOUT <<'EOF';

The author doesn't have access to all terminals (or all versions of terminals).
If termdetect doesn't detect your terminal, you can help greatly by submitting
the test results for your particular terminal.

1. Run  termdetect --dump

2. Create a new issue at https://github.com/DeeNewcum/termdetect/issues
   or contact me via any method mentioned at https://github.com/DeeNewcum

3. In the information you send, include:

    - the output of   termdetect --dump

    - the name and version number of your terminal

    - the reason for submitting the data, eg:
            - there was no entry for this terminal
            - there was an entry, but it didn't correctly identify your terminal

EOF
    exit;
}


# look in various places that the termmatch.src file could be, and if not found,
# tell the user where they can go stick it
sub locate_termmatch_file {
    my @possible_locations = (
        "$FindBin::Bin/termmatch.src",      # in the same directory as this script
        "$ENV{HOME}/.termmatch.src",
        "/etc/termmatch.src",
        );
    foreach my $loc (@possible_locations) {
        return $loc if (-e $loc);
    }
    print STDERR <<"EOF";
Error: File 'termmatch.src' not found.

Please copy it from the installation tarball to one of these places:
    - the same directory as this script ($FindBin::Bin)
    - \$HOME/.termmatch.src
    - /etc/termmatch.src
EOF
    exit 1;
}


sub TERM_fallback {
    my ($proposed_term, $termmatch_db) = @_;

    my $termmatch_entry = $termmatch_db->{$proposed_term};
    my @fallback_list = @{$termmatch_entry->{termnames}};
    if ($termmatch_entry->{fields}{fallback}) {
        push @fallback_list,
             split /\|/,
                   $termmatch_entry->{fields}{fallback}{assign};
    }
        #print Dumper \@fallback_list; exit;

    foreach my $fallback (@fallback_list) {
        if (does_terminfo_exist($fallback)) {
            return $fallback;
        }
    }

    return undef;
}


# check the local computer's terminfo information to see if the proposed $TERM
# is found there
sub does_terminfo_exist {
    my ($term) = @_;
    # there are many ways to do this:
    #   - toe -a    (or just `toe` in Solaris)
    #   - infocmp $TERM
    #   - tput -T$TERM longname;  echo $?

    # for now, we just implement the tput one
    my $pid = fork();
    defined($pid)   or die $!;
    if (!$pid) {
        open STDOUT, '>', '/dev/null';
        open STDERR, '>', '/dev/null';
        exec "tput", "-T$term", "longname";
    }
    waitpid($pid, 0);
    my $error_value = ($? >> 8);
    return ($error_value == 0);
}


sub help_install_terminfos {
    die <<'EOF';
Instructions for installing the full set of terminfo entries:

On Debian or Ubuntu:
    sudo apt-get install ncurses-term
                        
Otherwise:
    TMP=$(mktemp);
    curl http://invisible-island.net/datafiles/current/terminfo.src.gz | gzip -dc > $TMP;
    tic $TMP; rm $TMP
            (run that as root if you want, otherwise it will install things
             in ~/.terminfo/ )
EOF
}


sub show_snapshot {
    my ($test_results) = @_;

    # Patterns that may potentionally match the current results.
    # If one of these patterns matches, then that's really good, because it increases the 
    # chances that we'll match other results.
    #
    # Left-most are tried first, right-most tried last.
    my %generalizations = (
        r_ext_cursor_pos    => ["\e[%+R"],
        r_window_pos        => ["\e[3;%+t"],
        r_window_size_px    => ["\e[4;%+t"],
        r_window_size_char  => ["\e[8;%+t"],
        r_screen_size       => ["\e[9;%+t"],
        r_window_title      => ["\e]l%*\e\\"],
        r_window_icon_label => ["\e]L%*\e\\"],
    );
    foreach my $list (values %generalizations) {
        unshift @$list, '';         # highest priority:  match an empty string
        push    @$list, '%+';       # lowest priority:  match a non-empty string
    }
    foreach my $cap (sort keys %$test_results) {
        next if $Termdetect_Tests::rarely_tested_synthetics{$cap};
        my $r = summarize_result($test_results->{$cap});
        foreach my $gen (@{ $generalizations{$cap} }) {
            if (Termdetect_Match::match_one_field($test_results->{$cap}, {assign => $gen})) {
                ($r) = ansi_escape($gen);
                last;
            }
        }
        if ($cap eq 'r_device_attr2' && $test_results->{$cap}{received} =~ /^\e(\[>[^;]*;)[^;]*(;.*c)$/) {
            $r = "\\E$1\%+$2";
        }
        printf "    %s=%s,\n", $cap, $r;
    }
}


# quickly read a whole file         see also: File::Slurp and IO::All->slurp()
sub slurp {my$p=open(my$f,"$_[0]")or die$!;my@o=<$f>;close$f;waitpid($p,0);wantarray?@o:join("",@o)}




__END__
termdetect

  -t    only display the matched $TERM

  --check=<term>
        Used to debug termmatch.src.  Displays extra information about how the
        current terminal matches up to the specified entry in termmatch.src.

  --check
        Displays extra information about EVERY entry in termmatch.src.

  --nose
        "No Side Effects".  Doesn't run tests that may have side-effects.
        Gibberish may still be displayed on your screen, but they will be
        (mostly) erased before exiting.  Most tests don't have side-effects, so
        using this option doesn't greatly reduce the chances of correctly
        identifying your terminal.

  --snapshot
        Outputs the current tests results in a form that's suitable for 
        cut-n-pasting into termmatch.src.

  --dump
        Dumps the result of all tests run.
        Similar to --snapshot, but gives a little more detailed information.

  --version
        Show version number.

  --result=<test_id>
        Display the result of a single test.  To get a list of test_ids you
        can use, run   termdetect --dump

  --help-submit
        A guide for submitting test results to the developer, so that more
        terminal types will be recognized.
