#!/usr/bin/env perl
#
# This file is generated code.
# Please DO NOT EDIT or send patches for it.
#
# The source is available at:
#    https://github.com/DeeNewcum/termdetect
# Submit patches against the individual files that build it.
#
#
# You may redistribute this program and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Copyright (C) 2014  Dee Newcum
 




# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"FingerprintDB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FINGERPRINTDB';
  package FingerprintDB; sub fingerprint_db {join '', <DATA>}; 1
  __DATA__
  # The database of known fingerprints.  This is the core of termdetect.
  #
  # This file's syntax is exactly the same as terminfo's in most places, with a few slight changes.
  #
  # For more info, see:
  #       https://github.com/DeeNewcum/termdetect/blob/master/doc/fingerprint_db.md
  
  vte|VTE is used in GNOME Terminal; XFCE4 Terminal; and many others https://www.ohloh.net/p/vte,
      TERM=vte-256color|gnome-256color,
      m_c1=%x+3,
      m_cancel=%x+4,
      m_esc=%x+5,
      m_null_inside=%x+2,
      m_pad_null=,
      m_sub=%x+4,
      r_device_attr=\E[?62;%*c,
      r_device_attr2=\E[>1;%+;0c,
      r_device_attr3=,
      r_device_status=\E[0n,
      r_enquiry=,
      r_ext_cursor_pos=\E[%+R,
      r_printer_status=\E[?11n,
      r_screen_size=\E[9;%+t,
      r_term_id=\E[?62;%*c,
      r_term_param=%x+3,
      r_window_icon_label=\E]L%*\E\\,
      r_window_pos=\E[3;%+t,
      r_window_size_char=\E[8;%+t,
      r_window_size_px=\E[4;%+t,
      r_window_state=\E[1t,
      r_window_title=\E]l%*\E\\,
      s_ff_clears=false,
  
  linux|Linux console,
      TERM=linux-16color,
      m_c1=%x+3,
      m_cancel=,
      m_esc=,
      m_null_inside=,
      m_pad_null=,
      m_sub=,
      r_device_attr=\E[?6c,
      r_device_attr2=%x+1,
      r_device_attr3=%x+1,
      r_device_status=\E[0n,
      r_enquiry=,
      r_ext_cursor_pos=,
      r_printer_status=,
      r_screen_size=,
      r_term_id=\E[?6c,
      r_term_param=,
      r_window_icon_label=,
      r_window_pos=,
      r_window_size_char=,
      r_window_size_px=,
      r_window_state=,
      r_window_title=,
      s_ff_clears=false,
  
  # The xterm from http://invisible-island.net/ (specifically version #297)
  # 
  # Tips for looking through source code:
  #       - search for "unparse"
  #       - charproc.c -- most of the reply code is here
  #       - for the actual characters that trigger these conditions (eg. CASE_DA2), run:
  #               grep PARSE_T VTPrsTbl.c | sed 's/CSI/ESC [/'
  #               
  # You can also get the "trace" messages by rebuilding the source code:
  #       sudo apt-get install xutils-dev x11proto-core-dev libxt-dev libxmu-headers libxaw7-dev
  #       ./configure --enable-trace
  #       make
  # then it should leave a file named Trace-parent.out in the current directory.
  # To create a log for a specific escape code, run:
  #       ./xterm &
  #       echo -e -n "\e[?6n"; exit
  # Then to view the log, run this outside of xterm:
  #       grep '^CASE_\|^parse' Trace-parent.out  | perl -ple 's/^(CASE_.*)/$1\n/' | tail -50
  # and ignore sections with "CASE_PRINT".  Note that "001B" is the escape character.
  xterm*v297,
      TERM=xterm+255color|xtermc,
      # m_c1=%x+2,
      m_cancel=,
      m_esc=,
      m_null_inside=,
      m_pad_null=,
      m_sub=,
          # source code -- search for "CASE_DA1"
      r_device_attr=\E[?%+c,
          # source code -- search for "CASE_DA2"
      r_device_attr2=\E[>%+;0c,
          # source code -- search for "CASE_DECRPTUI"
      # blank most of the time, except when in VT420 mode
      r_device_attr3=%*,
      r_device_status=\E[0n,
      r_enquiry=,
      r_ext_cursor_pos=\E%+R,
          # source code -- search for "CASE_CPR" then "case 15"
      # blank unless it's in VT200 mode or above
      r_printer_status=%*,
      r_screen_size=,
          # source code -- search for "DECID"  (gotcha -- note fallthrough to CASE_DA1!)
      r_term_id=\E[?%+c,
          # source code -- search for "CASE_DECREQTPARM"
      # can be blank sometimes
      r_term_param=%*,
      r_window_icon_label=,
      r_window_pos=,
      r_window_size_char=,
      r_window_size_px=,
      r_window_state=,
      r_window_title=,
      s_ff_clears=false,
  
  # The xterm that comes with X11 release 6.
  #   (specifically, this data comes from Solaris 10, and X11 release 6.4)
  xterm-r6,
      m_c1=%x+3,
      m_cancel=,
      m_esc=,
      m_null_inside=,
      m_pad_null=,
      m_sub=,
      r_device_attr=\E[?1;2c,
      r_device_attr2=\E[?1;2c,
      r_device_attr3=\E[?1;2c,
      r_device_status=\E[0n,
      r_enquiry=,
      r_ext_cursor_pos=,
      r_printer_status=,
      r_screen_size=,
      r_term_id=\E[?1;2c,
      r_term_param=\E[2;1;1;112;112;1;0x,
      r_window_icon_label=,
      r_window_pos=,
      r_window_size_char=,
      r_window_size_px=,
      r_window_state=,
      r_window_title=,
      s_ff_clears=false,
  
  # source code -- search for "ldisc_send" in terminal.c
  putty,
      TERM=putty-256color,
      m_c1=,
      m_cancel=,
      m_esc=,
      m_null_inside=,
      m_pad_null=,
      m_sub=,
      r_device_attr=\E[?6c,
      # DA2 *ALWAYS* reports version 136
      r_device_attr2=\E[>0;136;0c,
      r_device_attr3=,
      r_device_status=\E[0n,
      r_enquiry=PuTTY,
      r_ext_cursor_pos=,
      r_printer_status=,
      r_screen_size=,
      # This is the usual response.  However, it can be changed via:    \e [ 50 ; ... " p
      r_term_id=\E[?6c,
      # source code -- search for "DECREQTPARM";  this is a hard-coded value
      r_term_param=\E[2;1;1;112;112;1;0x,
      r_window_icon_label=\E]L%*\E\\,
      r_window_pos=\E[3;%+t,
      r_window_size_char=\E[8;%+t,
      r_window_size_px=\E[4;%+t,
      r_window_state=\E[%+t,
      r_window_title=\E]l%*\E\\,
      s_ff_clears=true,
  
  rxvt*unknown_version,
      TERM=rxvt-256color,
      m_c1=%x+3,
      m_cancel=%x+1,
      m_esc=,
      m_null_inside=%x+1,
      m_pad_null=,
      m_sub=%x+1,
      r_device_attr=\E[?1;2c,
      r_device_attr2=\E[?1;2c,
      r_device_attr3=\E[?1;2c,
      r_device_status=\E[0n,
      r_enquiry=\E[?1;2c,
      r_ext_cursor_pos=\E[%+R,
      r_printer_status=,
      r_screen_size=,
      r_term_id=\E[?1;2c,
      r_term_param=,
      r_window_icon_label=,
      r_window_pos=\E[3;%+t,
      r_window_size_char=\E[8;%+t,
      r_window_size_px=\E[4;%+t,
      r_window_state=\E[1t,
      r_window_title=,
      s_ff_clears=false,
  
  # specifically http://archive.ubuntu.com/ubuntu/pool/universe/r/rxvt/rxvt_2.7.10-2.dsc
  rxvt*v2.7.10,
      m_cancel=,
      m_sub=,
      r_device_attr2=\E[>82;%+;0c,
      r_device_attr3=,
      r_ext_cursor_pos=,
      r_term_param=\E[2;1;1;112;112;1;0x,
      r_window_icon_label=,
      r_window_pos=,
      r_window_size_char=,
      r_window_size_px=,
      r_window_state=,
      use=rxvt*unknown_version,
  
  aterm,
      r_window_pos=,
      r_window_size_char=,
      r_window_size_px=,
      r_window_state=,
      r_window_title=\E]l%*\E\\,
      use=rxvt*unknown_version,
  
  rxvt-unicode,
      # the $TERM name of "rxvt-unicode" is a patch added by Debian, in package 'ncurses-base'
      TERM=rxvt-unicode|rxvt-88color|rxvt,
      m_c1=%x+2,
      m_cancel=,
      m_esc=,
      m_null_inside=%x+1,
      m_pad_null=,
      m_sub=,
      r_device_attr=\E[?1;2c,
      r_device_attr2=\E[>85;95;0c,
      r_device_attr3=,
      r_device_status=\E[0n,
      r_enquiry=\E[?1;2c,
      r_ext_cursor_pos=,
      r_printer_status=,
      r_screen_size=\E[9;%+t,
      r_term_id=\E[?1;2c,
      r_term_param=\E[2;1;1;128;128;1;0x,
      r_window_icon_label=%+,
      r_window_pos=\E[3;%+t,
      r_window_size_char=\E[8;%+t,
      r_window_size_px=\E[4;%+t,
      r_window_state=\E[1t,
      r_window_title=%+,
      s_ff_clears=false,
  
  mrxvt,
      TERM=mrxvt-256color,
      m_c1=%x+3,
      m_cancel=,
      m_esc=,
      m_null_inside=%x+1,
      m_pad_null=,
      m_sub=,
      r_device_attr=\E[?1;2c,
      r_device_attr2=\E[>82;%+;0c,
      r_device_attr3=,
      r_device_status=\E[0n,
      r_enquiry=\E[?1;2c,
      r_ext_cursor_pos=,
      r_printer_status=,
      r_screen_size=,
      r_term_id=\E[?1;2c,
      r_term_param=\E[2;1;1;112;112;1;0x,
      r_window_icon_label=,
      r_window_pos=\E[3;%+t,
      r_window_size_char=\E[8;%+t,
      r_window_size_px=\E[4;%+t,
      r_window_state=\E[1t,
      r_window_title=,
      s_ff_clears=false,
  
  screen*4.00.02|GNU Screen,
      TERM=screen-256color,
      m_c1=,
      m_cancel=,
      m_esc=,
      m_null_inside=%x+1,
      m_pad_null=,
      m_sub=,
      r_device_attr=\E[?1;2c,
      r_device_attr2=\E[>83;%+;0c,
      r_device_attr3=,
      r_device_status=\E[0n,
      r_enquiry=,
      r_ext_cursor_pos=,
      r_printer_status=,
      r_screen_size=,
      r_term_id=\E[?1;2c,
      r_term_param=\E[2;1;1;112;112;1;0x,
      r_window_icon_label=,
      r_window_pos=,
      r_window_size_char=,
      r_window_size_px=,
      r_window_state=,
      r_window_title=,
      s_ff_clears=false,
  
  # in v4.00.03jw4 (git change b4aa8750b45e7b75ab5a837503dc0a6b2e177bf9),
  # support was added for CSI 11t, 7t, and 21t
  screen*4.00.03jw4|GNU Screen,
      use=screen*4.00.02,
      r_window_state=\E[1t,
      r_window_title=\E]l%*\E\\,
  
  securecrt,
      TERM=vt100,
      # ^^ this REALLY varies, based on what its "emulation" setting is
      # ^^ TODO: do some work to see what the closest match actually is
      #
      # online suggestions:
      #       - http://tech.groups.yahoo.com/group/mutt-users/message/37609
      m_cancel=,
      m_esc=,
      m_null_inside=,
      m_pad_null=,
      m_sub=,
      r_device_attr=\E[?1;2c,
      r_device_attr2=%x+1,
      r_device_attr3=%x+1,
      r_device_status=\E[0n,
      r_enquiry=,
      r_ext_cursor_pos=,
      r_printer_status=\E[?10n,
      r_screen_size=,
      r_term_id=\E[?1;2c,
      r_term_param=\E[2;1;1;120;120;1;0x,
      r_window_icon_label=,
      r_window_pos=,
      r_window_size_char=,
      r_window_size_px=,
      r_window_state=,
      r_window_title=,
      s_ff_clears=false,
  
  tmux,
      TERM=xterm-new|screen-256color|screen,
      m_c1=%x+3,
      m_cancel=,
      m_esc=,
      m_null_inside=,
      m_pad_null=,
      m_sub=,
      r_device_attr=\E[?1;2c,
      r_device_attr2=\E[>0;95;0c,
      r_device_attr3=,
      r_device_status=\E[0n,
      r_enquiry=,
      r_ext_cursor_pos=,
      r_printer_status=,
      r_screen_size=,
      r_term_id=,
      r_term_param=,
      r_window_icon_label=,
      r_window_pos=,
      r_window_size_char=,
      r_window_size_px=,
      r_window_state=,
      r_window_title=,
      s_ff_clears=false,
  
  mosh,
      TERM=xterm-256color,
         # ^^ this is the value that's automatically set by the Mosh server
      m_c1=%x+3,
      m_cancel=,
      m_esc=,
      m_null_inside=,
      m_pad_null=,
      m_sub=,
      r_device_attr=\E[?62c,
      r_device_attr2=\E[>1;10;0c,
      r_device_attr3=,
      r_device_status=\E[0n,
      r_enquiry=,
      r_ext_cursor_pos=,
      r_printer_status=,
      r_screen_size=,
      r_term_id=,
      r_term_param=,
      r_window_icon_label=,
      r_window_pos=,
      r_window_size_char=,
      r_window_size_px=,
      r_window_state=,
      r_window_title=,
      s_ff_clears=false,
  
  teraterm,
      m_c1=%x+1,
      m_cancel=,
      m_esc=,
      m_null_inside=,
      m_pad_null=,
      m_sub=,
      r_device_attr=\E[?1;2c,
      r_device_attr2=\E[>32;100;2c,
      # TeraTerm has a curious response to DA3:    http://ttssh2.sourceforge.jp/manual/en/setup/teraterm-term.html#TerminalUID
      r_device_attr3=\EP!|%*\E\\,
      r_device_status=\E[0n,
      r_enquiry=,
      r_ext_cursor_pos=,
      r_printer_status=,
      r_screen_size=\E[9;%+t,
      r_term_id=\E[?1;2c,
      r_term_param=,
      r_window_icon_label=\E]L%*\E\\,
      r_window_pos=\E[3;%+t,
      r_window_size_char=\E[8;%+t,
      r_window_size_px=\E[4;%+t,
      r_window_state=\E[1t,
      r_window_title=\E]l%*\E\\,
      s_ff_clears=false,
  
  dtterm,
      m_c1=,
      m_cancel=,
      m_esc=,
      m_null_inside=,
      m_pad_null=,
      m_sub=,
      r_device_attr=\E[?62;1;2;6;7;8;9c,
      r_device_attr2=%x+1,
      r_device_attr3=%x+1,
      r_device_status=\E[0n,
      r_enquiry=,
      r_ext_cursor_pos=,
      r_printer_status=\E[?13n,
      r_screen_size=,
      r_term_id=\E[?62;1;2;6;7;8;9c,
      r_term_param=\E[2;1;1;112;112;1;0x,
      r_window_icon_label=\E]L%*\E\\,
      r_window_pos=\E[3;%+t,
      r_window_size_char=\E[8;%+t,
      r_window_size_px=\E[4;%+t,
      r_window_state=\E[1t,
      r_window_title=\E]l%*\E\\,
      s_ff_clears=false,
  
  konsole,
      TERM=konsole-256color,
      m_c1=,
      m_cancel=%x+1,
      m_esc=,
      m_null_inside=,
      m_pad_null=,
      m_sub=%x+1,
      r_device_attr=\E[?1;2c,
      r_device_attr2=\E[>0;115;0c,
      r_device_attr3=%x+1,
      r_device_status=\E[0n,
      r_enquiry=,
      r_ext_cursor_pos=,
      r_printer_status=,
      r_screen_size=,
      r_term_id=\E[?1;2c,
      r_term_param=\E[2;1;1;112;112;1;0x,
      r_window_icon_label=,
      r_window_pos=,
      r_window_size_char=,
      r_window_size_px=,
      r_window_state=,
      r_window_title=,
      s_ff_clears=false,
  
  nsterm|Terminal.app as found in OS/X,
      TERM=nsterm-256color,
      m_c1=%x+3,
      m_cancel=%x+0,
      m_esc=%x+0,
      m_null_inside=%x+0,
      m_pad_null=%x+0,
      m_sub=%x+0,
      r_device_attr=%x+0,
      r_device_attr2=%x+0,
      r_device_attr3=%x+0,
      r_device_status=%x+0,
      r_enquiry=%x+0,
      r_ext_cursor_pos=,
      r_printer_status=%x+0,
      r_screen_size=,
      r_term_id=%x+0,
      r_term_param=%x+0,
      r_window_icon_label=,
      r_window_pos=\E[3;%+t,
      r_window_size_char=\E[8;%+t,
      r_window_size_px=\E[4;%+t,
      r_window_state=%x+0,
      r_window_title=,
      s_ff_clears=false,
  
  iTerm2.app,
      m_c1=%x+3,
      m_cancel=%x+0,
      m_esc=%x+0,
      m_null_inside=%x+1,
      m_pad_null=%x+0,
      m_sub=%x+0,
      r_device_attr=%x+0,
      r_device_attr2=\E[>0;%+;c,
      r_device_attr3=%x+2,
      r_device_status=%x+0,
      r_enquiry=%x+0,
      r_ext_cursor_pos=,
      r_printer_status=%x+0,
      r_screen_size=\E[9;%+t,
      r_term_id=%x+0,
      r_term_param=%x+0,
      r_window_icon_label=\E]L%*\E\\,
      r_window_pos=\E[3;%+t,
      r_window_size_char=\E[8;%+t,
      r_window_size_px=\E[4;%+t,
      r_window_state=%x+0,
      r_window_title=\E]l%*\E\\,
      s_ff_clears=false,
  
  # data specifically from mintty v1.1.3
  mintty,
      TERM=cygwinB19,
      m_c1=%x+3,
      m_cancel=,
      m_esc=,
      m_null_inside=,
      m_pad_null=,
      m_sub=,
      r_device_attr=\E[?1;2c,
      r_device_attr2=\E[>77;%+;0c,
      r_device_attr3=,
      r_device_status=\E[0n,
      r_enquiry=,
      r_ext_cursor_pos=,
      r_printer_status=,
      r_screen_size=\E[9;%+t,
      r_term_id=\E[?1;2c,
      r_term_param=\E[2;1;1;112;112;1;0x,
      r_window_icon_label=,
      r_window_pos=\E[3;%+t,
      r_window_size_char=\E[8;%+t,
      r_window_size_px=\E[4;%+t,
      r_window_state=\E[2t,
      r_window_title=,
      s_ff_clears=false,
FINGERPRINTDB

$fatpacked{"Termdetect_Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERMDETECT_ENCODING';
  # Copyright (C) 2014  Dee Newcum
  # https://github.com/DeeNewcum/termdetect
  #
  # You may redistribute this program and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
  #---------------------------------------------------------------------------------------------------
  
  
  # This performs tests on the terminal, to try to determine what character-encoding the terminal
  # is set to.
  package Termdetect_Encoding;
  
      use strict;
      use warnings;
  
      use Termdetect_IO;
      use bytes qw();
  
      use Data::Dumper;
  
      use Exporter 'import';
      our @EXPORT = qw( do_encoding_tests );
  
  
  
  # TODO: We need to determine what the canonical names for these should be.
  #       Our main intention is for filling out the $LANG locale variable, however, 
  #       the "The Open Group Base Specifications Issue 6" says:
  #               "settings of language, territory, and codeset are implementation-defined"
  #
  #       For now, we're using the encoding name found on linux  (run `locale -a` or `locale -m`)
  
  
  # each test consists of:
  #       - one or more octets that we will send to the terminal
  #       - the expected X movement of the cursor in response to these octets
  #       - the expected Y movement of the cursor in response to these octets
  our %encoding_tests = (
  
      'utf8' => {
          # in case there are any font-support issues, (I think I've seen cases where missing glyphs
          # resulted in the character being rendered as [2, 0]) the codepoints that have named HTML
          # entities are somewhat more likely to be supported by most fonts?
          #       http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML
  
          'C2 A9'         => [1, 0],      # copyright symbol
          'C3 86'         => [1, 0],      # AE ligature
          'E2 80 94'      => [1, 0],      # em-dash
          'E2 99 A3'      => [1, 0],      # clubs symbol
      },
  
      'gb2312' => {
          'A1 A1'         => [2, 0],      # ideographic space
          'A1 DE'         => [1, 0],      # infinity symbol
          'A1 EA'         => [2, 0],      # fullwidth pound sign
          'A1 FE'         => [2, 0],      # geta mark
          'A1 EA'         => [2, 0],      # fullwidth pound sign
          'A2 C6'         => [1, 0],      # parenthesized digit two
          'A2 DA'         => [1, 0],      # circled digit two
          'A6 C8'         => [1, 0],      # theta
      },
  
      'shift_jis' => {
          '81 83'         => [2, 0],      # fullwidth less-than sign
          '81 E1'         => [1, 0],      # much less-than
          '81 CE'         => [1, 0],      # there exists
          '81 BE'         => [1, 0],      # union
          '81 BF'         => [1, 0],      # intersection
          '82 81'         => [2, 0],      # fullwidth latin small letter A
      }
  
  );
  
  
  sub do_encoding_tests {
      my $all_results = shift;
  
      my %encoding_results;
  
      # Do a union set-operation on all tests.  We will run all tests, regardless of which encoding
      # they're attached to.
      my @encoding_tests = uniq(map {keys %$_} values %encoding_tests);
          #print Dumper \@encoding_tests; exit;
  
      my %still_matching = map {$_ => 1}
                               keys %encoding_tests;
      foreach my $encoding_test (@encoding_tests) {
          debug_log("encoding $encoding_test\n");
          my $bytes = join "",
                      map {bytes::chr(hex($_))}
                          split ' ', $encoding_test;
          output("\r");
          run_test($bytes . "K",
                   sub {
                      my ($test_result) = @_;
                      process_encoding_results($encoding_test, $test_result, \%still_matching);
                   });
                  
      }
  
      read_phase {
          # record the final conclusion of the encoding tests
          if (scalar(keys(%still_matching)) == 1) {
              ($all_results->{s_encoding}{received}) = keys %still_matching;
          }
      };
  }
  
  
  sub process_encoding_results {
      my ($encoding_test, $test_result, $still_matching) = @_;
  
      foreach my $encoding (keys %$still_matching) {
          next unless exists $encoding_tests{$encoding}{$encoding_test};
          my $expected = $encoding_tests{$encoding}{$encoding_test};
  
          # backup one, since we printed an extra character ("K") at the end
          $test_result->{x_delta} = ($test_result->{x_delta} || 0) - 1;       
  
          # for newlines, we only care about delta-Y, we ignore delta-X
          if ($expected->[1] && $expected->[1] != ($test_result->{y_delta} || 0)
                  || $expected->[0] != ($test_result->{x_delta} || 0))
          {
              delete $still_matching->{$encoding};
  
              if (0) {                # set this to '1' to do the equivalent of --check for encodings
                  my $result = sprintf "(%d, %d)",
                                       $test_result->{x_delta} || 0,
                                       $test_result->{y_delta} || 0;
                  print "FAILED MATCH on encoding=$encoding and test='$encoding_test'.  Result was: $result\n\n\n";
              }
          }
      }
  }
  
  
  
  # removes duplicate elements from a list
  sub uniq {
      my %seen;
      grep { !$seen{$_}++ }
           @_
  }
  
  
  #use Encode;
  #sub xxd {Encode::_utf8_off(my$str=shift);open my$xxd,'|-','xxd'or die$!;print$xxd $str;close$xxd}    
  
  
  1;
TERMDETECT_ENCODING

$fatpacked{"Termdetect_IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERMDETECT_IO';
  # Copyright (C) 2014  Dee Newcum
  # https://github.com/DeeNewcum/termdetect
  #
  # You may redistribute this program and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
  #---------------------------------------------------------------------------------------------------
  
  
  # This module handles the lower-level I/O with the terminal -- sending ANSI sequences, and reading
  # responses.
  package Termdetect_IO;
  
      use strict;
      use warnings;
  
      use Time::HiRes qw[alarm];
      #use Term::ReadKey;
  
      use Data::Dumper;
  
      use Exporter 'import';
  
      our @EXPORT = qw(   run_test  read_phase  read_ansi_reply  output  cooked_mode
                          do_queued_async_reads debug_log );
  
  
      # constants
      our $DEBUG = 0;     # turns on lots of debugging
  
          # To watch the debug logs, run this command in another window:
          #     tail -fs0 --retry /var/tmp/termdetect.debug
  
      our $ASYNC = 1;     # Should reads be done asynchronously?
                          # If things are confusing AT ALL, just set this to 0 and debug from there.
                          # In theory, both modes should act exactly the same (except synchronous
                          # takes longer).  However, async won't work correctly if the reads get
                          # misaligned.
  
      our $CHECK_ALIGNMENT = 0;
                          # When $ASYNC is enabled, reads and writes can get misaligned.
                          # This option enables some extra work to check that reads/writes are aligned
                          # properly.  This makes the tests go *much* slower, but it's worth it to 
                          # find out where misalignment is happening.
                          #
                          # While testing, do NOT press any keys on the keyboard.
  
      our $EXTRA_DELAY = 0.20;            # (seconds)
                          # Add this much extra delay in between each test.
                          # Good choices range from 0.1 to 2.0.
                          # This is inactive unless $DEBUG is true.
  
      if ($DEBUG) {
          # turn on maximum debugging
          $CHECK_ALIGNMENT = 1;
          $ASYNC = 0;
      }
  
      # prototypes
      sub read_phase(&);
  
      # globals
      our @read_queue;
      our $debug_fh;
  
  
  debug__open_log();
  
  
  # From the outside, this routine merely sends an ANSI query, and reads the reply.
  # Internally though, we do it a somewhat fairly sophisticated way.  We surround the request with a
  # CPR queries both before and after, which means that 1) we know if the query caused the cursor
  # to move, and 2) if the terminal doesn't send any reply at all, we know that too, without having
  # to do any waiting.
  sub run_test {
      my ($sequence, $cps, $timeout, $no_cr) = @_;
      $cps ||= sub{};     # CPS = continuation-passing style
      $timeout = 2.0  unless defined($timeout);       # in floating-point seconds
                          # $no_cr -- usually we do a \r right before running the test;  setting this
                          #           to true disables that behavior
  
      my $test_result = {
          sent => $sequence,
      };
  
      if ($sequence =~ /^(?:\e\[|\x9B)\??6n$/) {
          # run_test() isn't designed to work with a Cursor Position Report command.  This is because
          # it uses a CPR-reply as a way to know when to stop reading.
          #
          # When we're asked to do a CPR sequence, we'll revert to much dumbed-down behavior instead.
          
          output("\r")        unless $no_cr;
          output($sequence,
                "\e[5n");      # add a DSR (device status report) to the end, so we can at least
                              # quickly determine a non-response
                              
          read_phase {
              my $reply = read_ansi_reply($timeout, 'n');
              $reply =~ s/\e\[\d+n$//s;
  
              $test_result->{received} = $reply;
              @_ = $test_result;  goto &$cps;       # continuation-passing style
          };
          return;
      }
  
      output("\r")    unless $no_cr;
      output("\e[6n", $sequence, "\e[6n");      # send a CPR (cursor position report) before and after
      #debug_show_remaining_input();
  
      read_phase {
          my $replies = '';
          my $start = time();
          while (1) {
              my $reply = read_ansi_reply($timeout, 'R');
              if (!defined($reply)) {
                  $test_result->{timeout} = 1;
                  last;
              }
              $replies .=  $reply;
  
              if ($replies =~ /.*\e\[(\d+);(\d+)R(.*)\e\[(\d+);(\d+)R/s) {
                  $test_result->{x_delta}  = $5 - $2;
                  $test_result->{y_delta}  = $4 - $1;
                  $test_result->{received} = $3;
  
                  if ($test_result->{y_delta} > 0) {
                      # if this test caused us to move down some lines, then
                      # move back up, to ensure that all "gibberish" is confined to a single line
                      output(("\r"        # move to the beginning of the line
                            . "\e[K"      # erase to end of line
                            . "\e[A")     # move up one line
                                  x $test_result->{y_delta});
                  }
  
                  @_ = $test_result;  goto &$cps;    # continuation-passing style
              }
  
              if (time() - $start > $timeout) {
                  $test_result->{timeout} = 1;
                  last;
              }
          }
          $replies =~ s/^.*?\e\[\d+;\d+R//s;
          $test_result->{received} = $replies;
          @_ = $test_result;  goto &$cps;    # continuation-passing style
      };
  }
  
  
  # There are two phases to every ANSI test:  1) write phase, 2) read phase.
  #
  # If we do all of the read phases AFTER doing all of the write phases (ie. do the reads
  # asynchronously), then the whole process goes much faster.  We minimize latency by doing this.
  sub read_phase(&) {
      my ($callback) = @_;
      if ($ASYNC && ! $CHECK_ALIGNMENT) {
          # run the callback asynchronously
          push(@read_queue, $callback);
      } else {
          # run the callback immediately, in-line
          $callback->();
  
          if ($CHECK_ALIGNMENT) {
              local $DEBUG = 0;       # don't show debugging output...  we INTEND to always timeout inside read_ansi_reply()
              my $any_more_reads = read_ansi_reply(0.1);      # the fractional number here can range from 0.1 to 2.0, depending on how slow the link between them is
              if (length($any_more_reads)) {
                  eval 'use Carp';                        # We don't want to rely on any non-core libraries unless really needed.  This will only be needed in development.
                  Carp::confess("out of alignment\n");
              }
          }
      }
      return undef;
  }
  
  
  sub do_queued_async_reads {
      while (@read_queue) {
          shift(@read_queue)->();
      }
  }
  
  
  
  
  
  
  # put the terminal in cooked mode   (and make sure it gets changed back before the program exits)
  use POSIX qw(:termios_h);
  sub cooked_mode {
      $|++;
  
      ## cooked mode, echo off
      #Term::ReadKey::ReadMode(2);
  
      #system 'stty', '-icanon', '-echo', 'eol', "\001";
  
      # from PerlFAQ8
      my $term = POSIX::Termios->new();
      $term->getattr(0);
      our $orig_lflag = $term->getlflag();
      $term->setlflag($orig_lflag & ~(ECHO | ECHOK | ICANON));
      $term->setcc(VTIME, 1);
      $term->setattr(0, TCSANOW);
  
  
      eval q{
          END {
              ## reset tty mode before exiting
              #Term::ReadKey::ReadMode(0);         
  
              #system 'stty', 'icanon', 'echo', 'eol', chr(0);
  
              # from PerlFAQ8
              my $term = POSIX::Termios->new();
              $term->getattr(0);
              $term->setlflag($orig_lflag);
              $term->setcc(VTIME, 0);
              $term->setattr(0, TCSANOW);
          }
      };
      die $@ if $@;
  }
  
  
  sub output {
      my $all = join "", @_;
      if ($DEBUG && $all ne "\r" && $all ne "\n" && $all ne "\r\e[K") {
          print $debug_fh "    sending: ", ansi_escape($all), "\n";
      }
      print STDERR $all;
  }
  
  
  # Gets an ANSI response, reading only as many characters as necessary, and waiting only as long
  # as necessary.
  #
  # $timeout
  #       Seconds to wait for a reply.  Use 0 for no timeout.
  #
  # $response_end_character
  #       If we see this character, we know the response is finished.
  #
  #       Special values:
  #           - empty string -- means "read one buffer's worth of data".
  #           - undef -- means "there is no specific end-character...  read until timeout
  #           - regexp reference -- match several characters, not just one
  #                   (use the "qr" quote-like operator)
  sub read_ansi_reply {
      my ($timeout,
          $response_end_character) = @_;
  
      $timeout = 1.0 unless defined($timeout);
  
      my $reply = '';
      $@ = "";
      eval {
          local $SIG{ALRM} = sub { die "alarm\n" };
          alarm($timeout)     if ($timeout != 0);
  
          if (defined($response_end_character) && $response_end_character eq '') {
              # an empty-string means "read everything that's in the buffer"...  this assumes that
              # the response will be sent all-at-once, and that there will be a slight timegap in between
              # the response and anything else the terminal sends to us
              my $numchars = sysread(STDIN, $reply, 1024);
              $reply = substr($reply, 0, $numchars);
          } else {
              while (1) {
                  if (defined(my $c = getc())) {
                      #print ".";
                      $reply .= $c;
                      if (defined($response_end_character)) {
                          if (ref($response_end_character) eq 'Regexp') {
                              last if ($reply =~ $response_end_character);
                          } else {
                              last if ($c eq $response_end_character);
                          }
                      }
                  }
              }
          }
      };
      die $@ if ($@ && $@ ne "alarm\n");
      alarm 0;
      if ($DEBUG) {
          if ($@ eq "alarm\n" && (!defined($reply) || length($reply) == 0)) {
              print $debug_fh "    timeout\n";
          } else {
              print $debug_fh "    read response:  ", ansi_escape($reply), "\n";
          }
      }
      return $reply;
  }
  
  
  sub ansi_escape { map {(my $a = $_);
          $a =~ s/\\/\\\\/g;
          $a =~ s/\e/\\E/g;
          $a =~ s/\x5/\\5/g;
          $a =~ s/\x9B/\\x9B/g;
          $a =~ s/([\x00-\x1f\x7f-\xff])/"\\x" . sprintf "%02X", ord($1)/ge;
          $a} @_ }
  
  # like ansi_escape, but don't escape newlines
  sub ansi_escape_no_nl {
      my $text = join('', @_);
      my @lines = split /[\n\r]+/, $text;
      @lines = map {ansi_escape($_)} @lines;
      return join("\n", @lines), "\n";
  }
  
  
  
  
  
  ##########################################################################################
  #####################################[ debugging ]########################################
  ##########################################################################################
              # this code should maybe be split off into its own package?
  
  # public method -- used by other modules to print to the debug log
  sub debug_log {
      if ($DEBUG) {
          # add extra delay in between each test
          select undef, undef, undef, $EXTRA_DELAY;
  
          print $debug_fh @_;
      }
  }
  
  
  sub debug__open_log {
      if ($DEBUG) {
          open $debug_fh, '>', '/var/tmp/termdetect.debug'        or die $!;
          print $debug_fh "\n" x 10;
  
          # autoflush
          my $prev_fh = select $debug_fh;
          $| = 1;
          select $prev_fh;
      } else {
          open $debug_fh, '>', '/dev/null';
      }
  }
  
  
  END {
      if ($DEBUG) {
          # indicate that the program is finished
          print $debug_fh "-"x80, "\n";
      }
  }
  
  
  
  
  1;
TERMDETECT_IO

$fatpacked{"Termdetect_Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERMDETECT_MATCH';
  # Copyright (C) 2014  Dee Newcum
  # https://github.com/DeeNewcum/termdetect
  #
  # You may redistribute this program and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
  #---------------------------------------------------------------------------------------------------
  
  
  # After we get a fingerprint from the current terminal, this module does the work of figuring 
  # out which database entries most closely match the fingerprint.
  package Termdetect_Match;
  
      use strict;
      use warnings;
  
      use Terminfo_Parser;
      use Termdetect_Tests;
  
      use Data::Dumper;
  
      use Exporter 'import';
  
      our @EXPORT = qw( match_fingerprint );
  
      use constant DEBUG_MATCHES => 1;
  
  
  # returns the name of the $TERM that best matches
  # (as long as there's only one entry.... if there are more than one, we can be instructed to
  #  error out)
  sub match_fingerprint {
      my ($current_fingerprint,       # the results from running all the tests on the current terminal
          $fingerprint_db,            # the contents of "fingerprints.src"
          $die_if_not_one,            # should we error out when there are more than one matches, or
                                      #           zero matches?   (optional param, defaults to yes)
              ) = @_;
  
      $die_if_not_one = 1        if (!defined($die_if_not_one));
  
      my $match_stats = calculate_match_statistics($current_fingerprint, $fingerprint_db);
          #print Dumper $match_stats;
  
  
      my @no_mismatches;      # list of all terminals that had zero mismatches, and at least one match
      my $highest_match;
      my $highest_match_numyes = 0;
      while (my ($term, $stats) = each %$match_stats) {
          if (!exists $stats->{n} && defined($stats->{y})) {
              push @no_mismatches, $term;
              if ($stats->{y} > $highest_match_numyes) {
                  $highest_match_numyes = $stats->{y};
                  $highest_match = $term;
              }
          }
      }
  
      #show_match_percentages($match_stats, 3);       exit;
  
      if (@no_mismatches > 1) {
          if ($die_if_not_one) {
              print STDERR "Error: Multiple terminals matched: ",
                          join(", ", @no_mismatches), "\n";
              print STDERR "\n\nIt would help out greatly if you could submit data about this,\n";
              print STDERR "since I don't have access to every terminal.\n";
              print STDERR "See       termdetect --help-submit\n";
              exit 1;
          } else {
              print STDERR "Error: Multiple terminals matched: ",
                          join(", ", @no_mismatches), "\n\n";
          }
      } elsif (@no_mismatches == 0) {
          if ($die_if_not_one) {
              if (keys %$match_stats) {
                  print STDERR "Error: No terminals matched exactly.  Terminals that were close:\n";
                  my $closest_match = show_match_percentages($match_stats, 5);
                  print STDERR "\nRun this for more info:\n    $0 --check='$closest_match'\n";
                  print STDERR "\n\nIt would help out greatly if you could submit data about this.\n";
                  print STDERR "See       termdetect --help-submit\n";
                  exit 1;
              } else {
                  die "Error: fingerprints.src is blank; there are no entries to match to.\n";
              }
          }
      } elsif (@no_mismatches == 1) {
          Termdetect_Tests::calculate_derived_values_after_match($current_fingerprint, $fingerprint_db, $highest_match);
      }
  
      return ($highest_match, scalar(@no_mismatches));
  }
  
  
  # for debugging, show the list of terminals, ordered by match percentage
  sub show_match_percentages {
      my ($match_stats, $limit_to) = @_;
              # $limit_to -- the number of items to display;   undef for unlimited
  
      my @match_percentage;       # list all terminals, sorted in order of match percentage
      foreach my $stats (values %$match_stats) {
          next unless ($stats->{total});          # we need a non-zero denominator
          $stats->{percentage} = int(100 * ($stats->{y} || 0) / $stats->{total});
      }
      @match_percentage = sort { $match_stats->{$b}{percentage} <=> $match_stats->{$a}{percentage} }
                               keys %$match_stats;
          #print Dumper \@match_percentage;    exit;
  
      my $ctr = 0;
      foreach my $term (@match_percentage) {
          printf STDERR "    %-15s  %3d%% match\n",
                        $term,
                        $match_stats->{$term}{percentage};
          $ctr++;
          last if (defined($limit_to) && $ctr >= $limit_to);
      }
  
      # return the terminal with the closest match
      return $match_percentage[0];
  }
  
  
  sub calculate_match_statistics {
      my ($current_fingerprint,       # the test results from the current terminal
          $fingerprint_db             # the contents of "fingerprints.src"
              ) = @_;
  
      #print ansi_escape_no_nl(Dumper $current_fingerprint);      exit;
      #print ansi_escape_no_nl(Dumper $fingerprint_db);      exit;
      
      my %pass_fail_count;
  
      foreach my $fingerprint_entry (values %$fingerprint_db) {
          my $termname = $fingerprint_entry->{termnames}[0];
  
          next if (exists $fingerprint_entry->{alias});     # skip aliases, we'll only process canonical names
  
          my $check_this = (exists $::ARGV{check} &&
                  ($::ARGV{check} eq '1' || $::ARGV{check} eq $termname));
  
          print "========[ $termname ]========\n"         if $check_this;
          #while (my ($cap, $test_result) = each %$current_fingerprint) {
          foreach my $cap (sort keys %$current_fingerprint) {
              my $test_result = $current_fingerprint->{$cap};
  
              next if ($cap =~ /^c_/);
              next if ($Termdetect_Tests::rarely_tested_synthetics{$cap} &&
                          !exists $fingerprint_entry->{fields}{$cap});
              
              printf "\t%-20s  ", $cap            if $check_this;
              $pass_fail_count{$termname}{total}++;
              if (exists $fingerprint_entry->{fields}{$cap}) {
                  my $yn = match_one_field($test_result, $fingerprint_entry->{fields}{$cap});
                  if ($yn) {
                      print "match\n"         if $check_this;
                  } else {
                      printf "MISMATCH -- got: %-25s  wanted: %s\n",
                              quote(summarize_result($test_result)), 
                              quote(ansi_escape($fingerprint_entry->{fields}{$cap}{assign}))
                                  if $check_this;
                  }
                  $pass_fail_count{$termname}{$yn ? 'y' : 'n'} ++;
              } else {
                  print "NOT PRESENT -- got: ", quote(summarize_result($test_result)), "\n"
                          if $check_this;
                  $pass_fail_count{$termname}{u} ++;      # "U" = unspecified
              }
          }
          print "\n"          if $check_this;
      }
      return \%pass_fail_count;
  }
  
          # returns the input, but surrounded in quotes
          sub quote {
              return '"' . join("", @_) . '"';
          }
  
  
  # Match one test-result against a capability in one fingerprint entry.
  # Returns true/false, regarding whether it matched.
  sub match_one_field {
      my ($test_result, $entry_cap) = @_;
  
      #print ansi_escape_no_nl(Dumper $entry_cap); exit;
  
      if (exists $entry_cap->{assign} && exists $test_result->{received}) {
          if ($entry_cap->{assign} !~ /\%/) {
              return ($test_result->{received} eq $entry_cap->{assign});
          } else {
              my @f = split /(\%[xy][-+]\d|\%[^xy])/, $entry_cap->{assign};
              my $pat = '';
              my ($pat_x_delta, $pat_y_delta);
              foreach my $f (@f) {
                  if ($f eq '%*') {
                      $pat .= ".*";
                  } elsif ($f eq '%+') {
                      $pat .= ".+";
                  } elsif ($f eq '%%') {
                      $pat .= '%';                # just the character '%'
                  } elsif ($f =~ /^\%([xy])([-+]\d)$/) {
                      if ($1 eq 'x') {
                          $pat_x_delta = int($2);
                      } elsif ($1 eq 'y') {
                          $pat_y_delta = int($2);
                      }
                  } elsif ($f =~ /^\%(.)$/) {
                      $pat .= quotemeta($1);      # an unsupported percent-char
                  } else {
                      $pat .= quotemeta($f);
                  }
              }
              # both the delta-x and delta-y MUST be acknowledged, or it isn't a match
              return 0     unless (($pat_x_delta || 0) == ($test_result->{x_delta} || 0)
                               &&  ($pat_y_delta || 0) == ($test_result->{y_delta} || 0));
              return ($test_result->{received} =~ /^$pat$/);
          }
      }
  }
  
  
  
  
  
  
  
  1;
TERMDETECT_MATCH

$fatpacked{"Termdetect_Tests.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERMDETECT_TESTS';
  # Copyright (C) 2014  Dee Newcum
  # https://github.com/DeeNewcum/termdetect
  #
  # You may redistribute this program and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
  #---------------------------------------------------------------------------------------------------
  
  
  # This module directly performs terminal-type tests on the terminal.
  # Routines that deal only with the test RESULTS are located elsewhere.
  # (also, tests that are encoding-specific are located in Termdetect_Encoding.pm)
  package Termdetect_Tests;
  
      use strict;
      use warnings;
  
      use Termdetect_Encoding;
      use Termdetect_IO;
  
      use Data::Dumper;
  
      use Exporter 'import';
  
      our @EXPORT = qw( perform_all_tests ansi_escape_no_nl ansi_escape summarize_result );
  
      
      # synthetic capabilities that are rarely tested against
      our %rarely_tested_synthetics = map {$_ => 1} qw(
              s_font_size
              s_screen_size
              s_window_icon_label
              s_window_size
              s_window_pos
              s_window_title
              s_encoding
          );
  
  
  
  
  # returns a data structure with the results of running the tests
  sub perform_all_tests {
      cooked_mode();
  
      ensure_cursor_position_supported();
      
      local our %all_results;     # this needs to be visible inside run_and_store_tests()
  
      run_and_store_test(r_device_status      => "\e[5n");
      run_and_store_test(r_printer_status     => "\e[?15n");
      run_and_store_test(r_term_id            => "\eZ");
      run_and_store_test(r_device_attr        => "\e[c");
      run_and_store_test(r_device_attr2       => "\e[>c");
      run_and_store_test(r_device_attr3       => "\e[=c");
      run_test("\e[=1c");         # some terminals interpret DA3 as a request to turn off the cursor, so we need to turn it back on
      run_and_store_test(r_term_param         => "\e[x");
      run_and_store_test(r_enquiry            => "\5");
  
      run_and_store_test(r_ext_cursor_pos     => "\e[?6n");
      run_and_store_test(r_window_title       => "\e[21t");
      run_and_store_test(r_window_icon_label  => "\e[20t");
      run_and_store_test(r_window_size_px     => "\e[14t");
      run_and_store_test(r_window_size_char   => "\e[18t");
      run_and_store_test(r_window_state       => "\e[11t");
      run_and_store_test(r_window_pos         => "\e[13t");
      run_and_store_test(r_screen_size        => "\e[19t");
  
      run_and_store_test(m_c1                 => "\x9B0K");
      run_and_store_test(m_pad_null           => "\x00");
      run_and_store_test(m_null_inside        => "\e\x00K");
      run_and_store_test(m_cancel             => "\e[?\x18");
      run_and_store_test(m_sub                => "\e[?\x1A");
      run_and_store_test(m_esc                => "\e[?\eK");
  
      synthetic__ff_clears();
      synthetic__window_size();
  
      Termdetect_Encoding::do_encoding_tests(\%all_results);
  
  
      if (0) {
          ################# things that haven't been given a test_id yet ###############
          read_phase {
              print "="x30, "[ r_* tests ]", "="x30, "\n";        };
  
          #run_and_display_test("\x9B5n",              "C1 version of DSR");
          run_and_display_test("\e[?50n",             "DSR - keyboard status");
          run_and_display_test("\e[?20n",             "DSR - user-defined key status");
  
          read_phase {
              print "="x30, "[ m_* tests ]", "="x30, "\n";        };
  
          run_and_display_test("\e[=",                "application keypad mode");
          run_and_display_test("\e[>",                "numeric keypad mode");
          run_and_display_test("\e|",                 "visual bell");
          run_and_display_test("\e[7",                "save cursor and attributes");
          run_and_display_test("\eg",                 "visual bell");
          run_and_display_test("\eP\e\\",             "DCS - device control string (blank)");
          run_and_display_test("\eP\e[0m\e\\",        "DCS - device control string (SGR reset); must be non-zero to pass");
          run_and_display_test("\e\%G",               "[ISO2022] select UTF8 character set");
          run_and_display_test("\e*C",                "[ISO2022] designate G2 character set");
          run_and_display_test("\e+C",                "[ISO2022] designate G3 character set");
          run_and_display_test("\e\\",                qq{"do nothing" sequence});
  
  
          read_phase {
              print "="x30, "[ s_* tests ]", "="x30, "\n";        };
  
          run_and_display_test("\ek-\e\\",            "set title");
          run_and_display_test("\ek-\e\\\e[21t",      "set + get title");
  
          read_phase {        print "\n\n"      };
      }
  
      do_queued_async_reads();
      output("\r\e[K");     # erase the line that we just sprayed gibberish over
  
      calculate_derived_values(\%all_results);
  
      return \%all_results;
  }
  
  
  ##########################################################################################
  ##################################[ synthetic tests ]#####################################
  ##########################################################################################
  
  
  # s_ff_clears -- does the form-feed character (^L) clear the screen?
  #
  # NOTE however, that some terminals will respond to FF by clearing the screen, but NOT moving the
  #       cursor back to (1,1).  What we're REALLY detecting here is moving the cursor back to
  #       (1,1), *not* whether the screen is cleared.
  #
  #       See:  http://www.aivosto.com/vbtips/control-characters.html#FF
  sub synthetic__ff_clears {
      return if ($::ARGV{nose});        # side effect: clears the screen
  
      DEBUG_test_name();
  
      output("\r\e[K");           # clear any gibberish that might be on this line, since we're dropping down a line
      output("\n");               # move a line first, to make sure we're not on the top line
      run_test("\x0c",
          sub {
              my ($test_result) = @_;
              our %all_results;           # pull this in from the 'local'ized copy in perform_all_tests()
  
              # did we move up one or more lines?
              $all_results{s_ff_clears}{received} =
                      (($test_result->{y_delta} || 0) < 0) ? 'true' : 'false';
  
              if ($all_results{s_ff_clears}{received} eq 'false') {
                  # if the screen wasn't cleared, move back up one line
                  output("\r\e[K"         # clear current line
                       . "\e[A");         # move up one line
              }
          });
  }
  
  
  # figure out the window size by moving the cursor all the way to the right, and then all the
  # way down
  sub synthetic__window_size {
      DEBUG_test_name();
  
      output("\e7");          # save cursor position
      output("\e[9999C");     # move all the way right
      output("\e[9999B");     # move all the way down
      output("\e[6n");        # request cursor position
      output("\e8");          # restore cursor
  
      read_phase {
          our %all_results;           # pull this in from the 'local'ized copy in perform_all_tests()
          my $reply = read_ansi_reply(1.0, 'R');
          if (defined($reply) && $reply =~ /\e\[(\d+);(\d+)R$/s) {
              $all_results{s_window_size}{received} = "$2 x $1";
          }
      };
  }
  
  
  ##########################################################################################
  ##################################[ standard tests ]######################################
  ##########################################################################################
  
  # We use the cursor-position report a lot...   if that doesn't work, then things will get hung up
  # and take way too long.
  # Figure this out before we waste a lot of time.
  sub ensure_cursor_position_supported {
  
      DEBUG_test_name();
  
      output("\e[6n");
  
      read_phase {
          my $reply = read_ansi_reply(1.0, qr/\e[^a-zA-Z]*[a-zA-Z]/);
          if (!defined($reply) || $reply !~ /\e\[\d+;\d+R$/s) {
              if ($ARGV{term_env}) {
                  print "$ENV{TERM}\n";       # passthrough existing terminal
              }
              close STDOUT; select undef,undef,undef,0.001;
              die "Terminal is unable to report the cursor position.  This is required for many tests.\n";
          }
      };
  }
  
  
  sub run_and_store_test {
      my ($test_id, $sequence) = @_;
  
      DEBUG_test_name($test_id);
  
      run_test($sequence, sub {
          my ($test_result) = @_;
          our %all_results;           # pull this in from the 'local'ized copy in perform_all_tests()
          $all_results{$test_id} = $test_result;
      });
  }
  
  
  sub run_and_display_test {
      my ($sequence) = shift;
      my $test_id = '';
      $test_id = shift    if (@_ >= 2);
      my $description = shift;
  
  
      run_test($sequence, sub {
          my ($test_result) = @_;
          print "\r";
          my $response = '';
          if ($test_result->{x_delta}) {
              $response = "[+$test_result->{x_delta}]";
          } else {
              $response = $test_result->{received};
          }
          printf  "%-20s  %-15s %-25s   %s\n",
                  $test_id,
                  ansi_escape($sequence),
                  ansi_escape($response),
                  $description;
      });
  }
  
  
  ##########################################################################################
  ##################################[ derived values ]######################################
  ##########################################################################################
  
  # some values are purely derived from others...  these don't require any I/O, and can be done after
  # the last call to do_queued_async_reads()
  sub calculate_derived_values {
      my ($all_results) = @_;
  
      if ($all_results->{r_window_size_char}{received}) {
          my (undef, $ch_y, $ch_x) = ansi_params($all_results->{r_window_size_char}{received});
          $all_results->{s_window_size}{received} = "$ch_x x $ch_y";
      }
      my ($fontsize_x, $fontsize_y);
      if ($all_results->{r_window_size_px}{received} && $all_results->{r_window_size_char}{received}) {
          my (undef, $px_y, $px_x) = ansi_params($all_results->{r_window_size_px}{received});
          my (undef, $ch_y, $ch_x) = ansi_params($all_results->{r_window_size_char}{received});
          #print Dumper [$ch_x, $ch_y];
          $fontsize_x = int($px_x / $ch_x);
          $fontsize_y = int($px_y / $ch_y);
          $all_results->{s_font_size}{received} = "$fontsize_x x $fontsize_y";
      }
      if ($all_results->{r_window_size_px}{received} && $all_results->{r_window_size_char}{received} &&
              $all_results->{r_screen_size}{received}) {
          my (undef, $s_y, $s_x) = ansi_params($all_results->{r_screen_size}{received});
          $s_x *= $fontsize_x;
          $s_y *= $fontsize_y;
          # We have a quandary here -- the screen-size we derived isn't EXACTLY right.
          # It could be off by as much as +/- $fontsize_x and $fontsize_y.
          #
          # One solution is just to round to the nearest N, where N is:
          #       8 for X         
          #       4 for Y
          # based on the greatest-common-factor for resolution widths and heights.
          $s_x = round_up($s_x, 8);
          $s_y = round_up($s_y, 4);
          $all_results->{s_screen_size}{received} = "$s_x x $s_y";
      }
      if ($all_results->{r_window_pos}{received}) {
          my (undef, $p_x, $p_y) = ansi_params($all_results->{r_window_pos}{received});
                      # ^^^^^^ is this backwards?  This is what libVTE uses, but it seems backwards.
          $all_results->{s_window_pos}{received} = "$p_x x $p_y";
      }
      if (($all_results->{r_window_title}{received} || '') =~ /^\e\]l(.*)\e\\$/) {
          $all_results->{s_window_title}{received} = $1;
      }
      if (($all_results->{r_window_icon_label}{received} || '') =~ /^\e\]L(.*)\e\\$/) {
          $all_results->{s_window_icon_label}{received} = $1;
      }
  }
  
  sub calculate_derived_values_after_match {
      my ($all_results, $fingerprint_db, $matched_term) = @_;
  
      calculate_version($all_results, $matched_term);
  }
  
  
  sub calculate_version {
      my ($all_results, $matched_term) = @_;
  
      return unless (exists $all_results->{r_device_attr2});
      my (undef, $da2) = split /;/, $all_results->{r_device_attr2}{received};
  
      # The exact interpretation of the second argument of DA2 varies based on terminal.
      # This is the only place in the code that we have terminal-specific code.  This really
      # out to be moved to fingerprints.src in some way.
      if ($matched_term eq 'vte') {
          $da2 =~ s/(\d\d)$//;
          my $last2digits = $1;
          $all_results->{s_term_version}{received} = sprintf "libvte v%0.2f.%d", $da2 / 100, $last2digits;
      } elsif ($matched_term =~ /^screen(?:_.*)?$/) {
          $da2 =~ s/(\d\d)$//;
          my $last2digits = $1;
          $all_results->{s_term_version}{received} = sprintf "v%0.2f.%02d", $da2 / 100, $last2digits;
      } elsif ($matched_term eq 'mrxvt') {
          # mrxvt's version number already has dots in it, which is a total violation of the spec
          $all_results->{s_term_version}{received} = "v$da2";     
      } elsif ($matched_term eq 'xterm') {
          $all_results->{s_term_version}{received} = "#$da2";
      } else {
          # otherwise, the version usually just means "we are feature-compatible with version XX of xterm"
      }
  }
  
  
      sub round_up {
          my ($n, $modulo) = @_;
          if ($n % $modulo) {
              $n += ($modulo - $n % $modulo);
          }
          return $n;
      }
  
  
  # given the {received} field, return the numeric parameters, as an array
  sub ansi_params {
      my ($received) = @_;
      return () unless defined($received);
      my @params = ($received =~ /(\d+)/g);
      return @params;
  }
  
  
  ##########################################################################################
  ############################[ debugging and human-readable ]##############################
  ##########################################################################################
  
  # when $Termdetect_IO::DEBUG is turned on, print out the provided test summary, before running
  # the test
  sub DEBUG_test_name {
      if ($Termdetect_IO::DEBUG) {
          if (!@_) {
              # if no name is given, use the caller's subroutine name
              my $caller_sub = (caller(1))[3];
              $caller_sub =~ s/^.*:://;
              @_ = ($caller_sub);
          }
          debug_log("test ", @_, "\n");
      }
  }
  
  
  sub summarize_result {
      my ($test_result) = @_;
      #print ansi_escape_no_nl(Dumper $test_result); exit;
      if ($test_result->{x_delta}) {
          return "%x+$test_result->{x_delta}";
      } else {
          return (ansi_escape($test_result->{received}))[0];
      }
  }
  
  
  sub debug_show_remaining_input {
      print "---- debug_show_remaining_input ----\n";
      while (my $reply = read_ansi_reply(0, '')) {
          print ansi_escape($reply), "\n";
      }
      exit;
  }
  
  
  sub ansi_escape { map {(my $a = $_);
          $a =~ s/\\/\\\\/g;
          $a =~ s/\e/\\E/g;
          $a =~ s/\x5/\\5/g;
          $a =~ s/\x9B/\\x9B/g;
          $a =~ s/([\x00-\x1f])/"\\x" . sprintf "%02X", ord($1)/ge;
          $a} @_ }
  
  
  # like ansi_escape, but don't escape newlines
  sub ansi_escape_no_nl {
      my $text = join('', @_);
      my @lines = split /[\n\r]+/, $text;
      @lines = map {ansi_escape($_)} @lines;
      return join("\n", @lines), "\n";
  }
  
  
  
  
  
  1;
TERMDETECT_TESTS

$fatpacked{"Terminfo_Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERMINFO_PARSER';
  # Copyright (C) 2014  Dee Newcum
  # https://github.com/DeeNewcum/termdetect
  #
  # You may redistribute this program and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
  #---------------------------------------------------------------------------------------------------
  
  
  # A Perl implemntation of a terminfo source parser.
  #
  # See the unit tests in parser/parser_unit_test -- we tested this somewhat well against the
  # original tic(1) parser.
  package Terminfo_Parser;
  
      use strict;
      use warnings;
  
      use Exporter 'import';
  
      our @EXPORT = qw( parse_terminfo ti_dump_terminal );
      our @EXPORT_OK = qw( terminfo_unescape );
  
  
  # terminfo(5) says of terminfo's syntax:
  #
  #      Entries  in  terminfo  consist  of  a  sequence of "," separated fields
  #      (embedded commas may be escaped with a backslash or notated  as  \054).
  #      White  space  after  the "," separator is ignored.  The first entry for
  #      each terminal gives the names which are known for the  terminal,  sepa-
  #      rated  by  "|"  characters.   The  first  name given is the most common
  #      abbreviation for the terminal, the last name given  should  be  a  long
  #      name  fully  identifying the terminal, and all others are understood as
  #      synonyms for the terminal name.  All names but the last  should  be  in
  #      lower  case and contain no blanks; the last name may well contain upper
  #      case and blanks for readability.
  #
  #      A  number  of  escape  sequences   are  provided  in  the  string valued
  #      capabilities for easy encoding of characters there.  Both \E and \e map
  #      to  an  ESCAPE character, ^x maps to a control-x for any appropriate x,
  #      and the sequences \n \l \r \t \b  \f  \s  give  a  newline,  line-feed,
  #      return, tab, backspace, form-feed, and space.  Other escapes include \^
  #      for ^, \\ for \, \, for comma, \: for :, and \0  for  null.   (\0  will
  #      produce  \200,  which does not terminate a string but behaves as a null
  #      character on most terminals, providing CS7 is specified.  See stty(1).)
  #      Finally, characters may be given as three octal digits after a \.
  
  #      ...
  #
  #      Sometimes  individual  capabilities must be commented out.  To do this,
  #      put a period before the capability name.  For example, see  the  second
  #      ind in the example above.
  
  #      ...
  #
  #      Numeric  capabilities are followed by the character "#" and then a
  #      positive value.
  
  #      ...
  #
  #      String valued capabilities, such as el (clear to end of line sequence)
  #      are given by the two-character code, an "=", and then a string ending
  #      at the next following ",".
  #       
  #      ...
  #
  #      The % encodings have the following meanings:
  #               (read terminfo(5) for full info about % encodings)
  #
  # The Single UNIX Specification further says:
  #
  #      Each description consists of a header (beginning in column 1) and one
  #      or more lines that list the features for that particular device. Every
  #      line in a terminfo source file must end in a comma. Every line in a
  #      terminfo source file except the header must be indented with one or
  #      more white spaces (either spaces or tabs).
  #
  #      Entries in terminfo source files consist of a number of
  #      comma-separated fields. White space after each comma is ignored. 
  #
  
  sub parse_terminfo  {
      my ($lines) = @_;
      return flatten_terminfo(_parse_terminfo($lines));
  }
  
  
  sub _parse_terminfo  {
      my ($lines) = @_;
  
      my @parsed;
  
      my @lines = split /\n/, $lines;
      our @process_fields;
      for (our $lineno=0; $lineno<@lines; $lineno++) {
          our %field = (lineno => $lineno);
          our @fields = ();
          our $is_continuation = 1;
          $lines[$lineno] =~ m{
                ^ \s* \# .*       # ignore comment lines
              | ^ \s* $           # ignore blank lines
              | ^( \s* )
                                      (?{ $is_continuation = length $^N    })
                  (?:
                      (?! \s )
                      ((?:  \\\d\d\d  |  [\\^][^\n]  |  [^,\\^\n=\#]  )+)
                         #  ^^^^^^^^     ^^^^^^^^     ^^^^^^^^^^^    various escape codes
                                      (?{ local $field{capability} = $^N   })
                      (?:     = ((?:  \\\d\d\d  |  [\\^][^\n]  |  [^,\\^\n]  )*)
                                ## same as above, but with [=\#] removed, and + changed to *
                                      (?{ local $field{assign} = $^N    })
                           | \# (\d+)
                                      (?{ local $field{num} = $^N    })
                           )?
                      , \s*  
                                      (?{ push(@fields, {%field})   })
                  )+ $
          }x
              or die "syntax error on line " . ($lineno+1) . "\n\t$lines[$lineno]\n";
  
          if (defined($is_continuation)) {
              if ($is_continuation) {
                  push(@process_fields, @fields);
              } else {
                  push(@parsed, process_fields(@process_fields)) if (@process_fields);
                  @process_fields = (@fields);
              }
          }
      }
      push(@parsed, process_fields(@process_fields)) if (@process_fields);
  
      return \@parsed;
  }
  
  
  sub process_fields {
      my @fields = @_;
  
      my $termfield = shift @fields;
  
      my @termnames = split /\|/, $termfield->{capability};
      my $descr = pop @termnames      if (@termnames >= 2);
      my %parsed = (
          termnames      => \@termnames,
          term_descr     => $descr,
          lineno_range   => [         # range of line numbers that this entry occupies
                  $termfield->{lineno},       # first line
                  $fields[-1]{lineno},        # last line
              ],
          );
  
      $parsed{fields} = [
              map {
                  $_->{assign} = terminfo_unescape($_->{assign})      if $_->{assign};
                  $_
              } @fields
          ];
  
      return \%parsed;
  }
  
  
  BEGIN {
      our %escapes = (
  
          "\\a"  => "\x07",   # bell
          "\\b"  => "\x08",   # backspace
          "\\f"  => "\x0c",   # form feed
          "\\e"  => "\e",     # escape
          "\\l"  => "\x0a",   # line feed
          "\\n"  => "\x0a",   # newline
          "\\r"  => "\x0d",   # return
          "\\s"  => " ",      # space
          "\\t"  => "\t",     # horizontal tab
          "\\0"  => "\200",   # null   (see detailed info about this in terminfo(5)...   it's not clear to me why we use \200 instead of \x00)
  
          "^\\"  => "\x1c",
          "^]"   => "\x1d",
          "^^"   => "\x1e",
          "^_"   => "\x1f",
  
          # plain escapes
          "\\,"  => ",",
          "\\:"  => ":",
          "\\\\" => "\\",
          "\\^"  => "^",
      );
      for ('a'..'z') {
          $escapes{"^$_"} = chr(ord($_) - 96);
      }
      #print Dumper \%escapes; exit;
  
  
  # The output of this should EXACTLY match tigetstr(3).
  # That is -- the percent parameters haven't been expanded (it doesn't do what tparm() does), but
  # all other escape-codes should be expanded.
  sub terminfo_unescape {
      local $_ = shift;
  
      s/
          \\(\d\d\d)    |
          (\%)(?=\\)    |         # i have no clue what the fuck this is...  but this is required to match the official parser's behavior
          ([\\^].)      |
          \%\{(\d\d+)\} |
          \%'([^']+)'   |
          (%'[^']+'|%.)
      /
              defined($1) ? chr(oct($1))
            : defined($2) ? $2
            : defined($3) ? ($escapes{lc $3} || substr($3, -1))
            : defined($4) ? unescape_percent_char($4)
            : defined($5) ? ("%'" . terminfo_unescape($5) . "'")
            : defined($6) ? $6 : "YOUBROKEIT"
          /gex;
      return $_;
  }
  }
  
      sub unescape_percent_char {
          my $charnum = shift;
          if ($charnum >= 32 && $charnum <= 126 && $charnum != 92) {
              return "\%'" . chr($charnum) . "'";
          } else {
              return "\%{$charnum}";
          }
      }
  
  
  # The terminfo specification allows for use= clauses (and @ items to cancel things inside uses).
  # This takes the parsed fields that contain use= clauses, and flattens everything out so you don't
  # have to do a lot of work to find out what the final values for a given $TERM are.
  sub flatten_terminfo {
      my ($parsed) = @_;
  
      ## gather up all aliases
      my %canonical_name;     # mapping from   canonical_name => entry_structure
      my %all_term_names;     # mapping from   alias => canonical_name
      foreach my $entry (@$parsed) {
          my $canonical = $entry->{termnames}[0];
  
          $canonical_name{$canonical} = $entry;
          foreach my $termname (@{$entry->{termnames}}) {
              $all_term_names{$termname} = $canonical;
          }
      }
  
      ## gather up all "use" entries
      my %first_level_uses;
      foreach my $entry (@$parsed) {
          my $canonical = $entry->{termnames}[0];
          foreach my $field (@{$entry->{fields}}) {
              if ($field->{capability} eq 'use') {
                  push @{$first_level_uses{$canonical}}, $field->{assign};
              }
          }
      }
  
      ## now, merge all the capabilities in the proper precedence order
      my %flattened;
      foreach my $canonical (keys %canonical_name) {
          # recursively explore the tree
          my $merged = merge_tree($canonical,
                                  {},
                                  \%canonical_name,
                                  \%all_term_names,
                                  \%first_level_uses,
                                  $canonical);
  
          # actually delete all entries that are explicitely marked "deleted"
          while (my ($cap, $field) = each %$merged) {
              delete $merged->{$cap} if (!defined($field));
          }
  
          $flattened{$canonical} = {
              %{$canonical_name{$canonical}},
              fields => $merged,
          };
      }
      #return \%flattened;
                  
      ## add aliases
      while (my ($alias, $canonical) = each %all_term_names) {
          if (!exists $flattened{$alias}) {
              $flattened{$alias} = {
                  alias => $canonical,
                  termnames => [$alias],      # $flattened{$canonical}{termnames},
              };
          }
      }
  
      return \%flattened;
  }
  
  
  
  # recursively explore the tree, merging the fields for a specific entry
  #       %$terms_seen gets built from top-down
  #       %$merged gets built from bottom-up
  sub merge_tree {
      my ($term,                  # the specific terminal to return the list of merged fields for
          $terms_seen,            # all terminals seen so far, when exploring the tree
                                  #           (note: this lists ONLY the parent nodes, in direct
                                  #           lineage...  it does NOT list siblings of parents)
          @passthru) = @_;
  
      my ($canonical_name,        # mapping from   canonical_name => entry_structure
          $all_term_names,        # mapping from   alias => canonical_name
          $first_level_uses,      # mapping from   canonical_name => ordered list of "use" entries for this level ONLY
          $orig_term,             # the $term from the first-level call to this
          ) = @passthru;
  
      #$num_dependencies{$orig_term}++;
  
      # according to terminfo(5):
      #           "The capabilities given before use override those in the base type named by use.
      #           If there are multiple use capabilities, they are merged in reverse order.
      #           That is, the rightmost use reference is processed first, then the one to its
      #           left, and so forth.  Capabilities given explicitly in the entry override
      #           those brought in by use references."
      my $merged = {};
      my %terms_seen = (%$terms_seen, $term => 1);
      foreach my $use (reverse @{$first_level_uses->{$term} || []}) {
          if (! exists $all_term_names->{$use}) {
              die "Terminal not found in line:    use=$use,\n";
          }
          $use = $all_term_names->{$use};         # canonicalize
          next if ($terms_seen{$use});            # avoid infinite loops
          my $subtree = merge_tree($use, \%terms_seen, @passthru);          # recursion step -- call ourselves
          $merged = merge_fields($merged, $subtree);
      }
      $merged = merge_fields($merged, 
                       field__list_to_hash(  $canonical_name->{$term}{fields}  ));
  
      return $merged;
  }
  
  
  # merge two sets of fields, with the "$a" one taking precedent over "$b"
  sub merge_fields {
      my $a = field__list_to_hash(shift);
      my $b = field__list_to_hash(shift);
  
      my %merged = %$a;
  
      while (my ($cap, $field) = each %$b) {
          if ($cap eq 'use') {
              next;       # we're handling the hierarchy elsewhere
          } elsif ($cap =~ s/\@$//) {
              delete $merged{$cap};
          } else {
              $merged{$cap} = $field;
          }
      }
      return \%merged;
  }
  
          # convert a list-ref of fields into a hash-ref of fields
          #       (or, if already a hash-ref...  just return it untouched)
          sub field__list_to_hash {
              my ($field_list) = @_;
              return $field_list  if ref($field_list) eq 'HASH';
              return {
                      map {$_->{capability} => $_}
                          @$field_list
                     };
          }
  
  
  
  
  #############################################################################
  ##############[ debugging only ]#############################################
  #############################################################################
  
  
  
  sub ti_dump_terminal {
      my @terms = sort {$a->{termnames}[0] cmp $b->{termnames}[0]} @_;
      my $return = '';
      foreach my $terminal (@terms) {
          $return .= "================[ " . join(" -- ", @{$terminal->{termnames}}, $terminal->{term_descr} || '') .
                      " ]================\n";
          if (exists $terminal->{alias}) {
              $return .= sprintf "%20s   %s\n\n", "alias of", $terminal->{alias};
              next;
          }
  
          my $fields = $terminal->{fields};
          if (ref($fields) eq 'HASH') {
              $fields = [ sort { ti_dump_sort_fields() } values %$fields ];
          }
          $return .= ti_dump_field(@$fields);
          $return .= "\n";
      }
      return $return;
  }
  
  
  sub ti_dump_field {
      my $return = '';
      foreach my $field (@_) {
          next if (!defined($field));
          $return .= sprintf "%20s", $field->{capability};
          if ($field->{assign}) {
              $return .= " = " . qquote($field->{assign}) . "\n";
          } elsif ($field->{num}) {
              $return .= " # " . qquote($field->{num}) . "\n";
          } elsif ($field->{deleted}) {
              $return .= " XXXXXXXXXXX deleted\n";
          } else {
              $return .= "\n";
          }
      }
      return $return;
  }
  
  
  sub ti_dump_sort_fields {
                          ti_field_type($a) cmp ti_field_type($b) ||
                          $a->{capability} cmp $b->{capability}
  }
  
  
  sub ti_field_type {
      my ($field) = @_;
      return "3assign" if ($field->{assign});
      return "2num" if ($field->{num});
      return "1bool";
  }
  
  
  sub qquote {my$q=Data::Dumper::qquote($_[0]);$q=~s/^"(.*)"$/$1/s;$q}
  
  1;
TERMINFO_PARSER

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/perl
# Copyright (C) 2014  Dee Newcum
# https://github.com/DeeNewcum/termdetect
#
# You may redistribute this program and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
#---------------------------------------------------------------------------------------------------


# auto-detect which terminal emulator we're talking to




    use strict;
    use warnings;

    # improved FindBin
    use Cwd 'abs_path';
    use File::Basename;
    use lib $FindBin::Bin = dirname( abs_path $0 );

    use Terminfo_Parser;
    use Termdetect_Tests;
    use Termdetect_Match;

    use Getopt::Long;
    use Data::Dumper;

    
    # constants
    use constant VERSION => "0.14";


our %ARGV;
process_cmdline();

# we can't detect the terminal type if there's no terminal connected in the first place
if (!-t STDERR || !-t STDIN) {       # isatty(3)
    die "Not connected to a terminal.\n";
}

my ($fingerprintdb_file, $fingerprintdb_location) = locate_fingerprintdb_file();

if ($ARGV{version}) {
    printf "termdetect, version %s  %s\n",
            VERSION, $fingerprintdb_location eq '<internal>' ? '(embedded fingerprints_db)' : '';
    exit;
}

## read in the fingerprint database
my $fingerprint_db = parse_terminfo($fingerprintdb_file);
    #print ti_dump_terminal(values %$fingerprint_db);      exit;

## read in the test results from the current terminal
my $fingerprint = perform_all_tests();
    #print Dumper $fingerprint;     exit;
    #print ansi_escape_no_nl(Dumper $fingerprint);      exit;

## ... and match them together
my ($fingerprint_name, $num_matches) = match_fingerprint($fingerprint, $fingerprint_db,
    !($ARGV{snapshot} || $ARGV{dump} || $ARGV{check} || $ARGV{term_env}));

($fingerprint->{s_fingerprint_name}{received} = $fingerprint_name)
        =~ s/\*.*//     if $fingerprint_name;



## generate the desired output
if ($ARGV{snapshot}) {
    show_snapshot($fingerprint);

} elsif ($ARGV{dump}) {
    foreach my $cap (sort keys %$fingerprint) {
        if (-t STDOUT) {
            printf "%25s  %s\n", $cap, summarize_result($fingerprint->{$cap});
        } else {
            print "$cap\t", summarize_result($fingerprint->{$cap}), "\n";
        }
    }

} elsif ($ARGV{result}) {
    if (exists $fingerprint->{$ARGV{result}}) {
        print summarize_result($fingerprint->{$ARGV{result}}), "\n";
    }

} elsif ($ARGV{term_env}) {
    if ($num_matches == 1) {
        my $final_term = find_best_TERM($fingerprint_name, $fingerprint_db);
        if ($final_term) {
            print "$final_term\n";
            # to deal with the problem of the keyboard-buffer being cleared, we indicate to the
            # user when it's safe to start typing   (see doc/side-effects.md)
            print STDERR "-\n"
                    unless (-t STDOUT);
        } else {
            print STDERR "The \$TERM for $fingerprint_name wasn't found.\n";
            print STDERR "        \n";
            print STDERR "\nTo install the full set of terminfo files:\n";
            help_install_terminfos();
        }
    } else {
        print "$ENV{TERM}\n";           # failed to match, so passthrough the existing terminal
        exit;
    }

} elsif (!$ARGV{check}) {
    if (defined($fingerprint_name)) {
        (my $fingerprint_name_display = $fingerprint_name) =~ s/\*.*//;
        $fingerprint_name_display .= "  --  $fingerprint_db->{$fingerprint_name}{term_descr}"
                    if ($fingerprint_db->{$fingerprint_name}{term_descr});
        my $suggested_term = find_best_TERM($fingerprint_name, $fingerprint_db);
        my @fields = (
                ['terminal',            $fingerprint_name_display],
                ['terminal version',    $fingerprint->{s_term_version}],
                ['encoding',            $fingerprint->{s_encoding}],
                ['terminal size',       $fingerprint->{s_window_size},         '(characters)'  ],
                ['font size',           $fingerprint->{s_font_size},           '(pixels)'  ],
                ['window position',     $fingerprint->{s_window_pos},          '(pixels)'  ],
                ['screen size',         $fingerprint->{s_screen_size},         '(pixels)'  ],
                ['suggested $TERM',     $suggested_term  ],
        );
        foreach my $field (@fields) {
            next unless defined($field->[1]);
            my $disp = $field->[1];
            if (ref($disp) eq 'HASH' && exists $disp->{received}) {
                $disp = $disp->{received};
            }
            printf "%20s:   %s", $field->[0], $disp;
            if (@$field == 3) {         # print the suffix, if any
                print "  ", $field->[2];
            }
            print "\n";
        }

        if (!does_terminfo_exist("vt100-putty")) {
            print STDERR "\nThe full set of terminfo entries haven't been installed.\n",
                           "To install them:\n";
            help_install_terminfos();
        }
    } else {
        print STDERR "No \$TERM matched.  Run again with --check for more information.\n";
        print "$ENV{TERM}\n"        if ($ARGV{term_env});      # pass through the existing terminal
    }
}




sub process_cmdline {
    Getopt::Long::GetOptions( \%ARGV,
                    map {"$_:s"}        # all options have optional arguments, like Getopt::Casual
        "help|h|?",
        "term_env|t",
        qw( check nose snapshot result dump help-submit version ),
    ) or usage();
    %ARGV = map {length()?$_:1} %ARGV;      # arguments are optional
    $ARGV{help} and usage();
    $ARGV{'help-submit'} and help_submit();
}


sub usage {
    print <DATA>;
    exit;
}

sub help_submit {
    print STDOUT <<'EOF';

The author doesn't have access to all terminals (or all versions of terminals).
If termdetect doesn't detect your terminal, you can help greatly by submitting
the fingerprint for your particular terminal.

1. Run  termdetect --dump

2. Create a new issue at https://github.com/DeeNewcum/termdetect/issues
   or contact me via any method mentioned at https://github.com/DeeNewcum

3. In the information you send, include:

    - the output of   termdetect --dump

    - the name and version number of your terminal

    - the reason for submitting the data:   if an existing entry didn't work, or it's a new entry

And thank you!
EOF
    exit;
}


# look in various places that the fingerprints.src file could be, and if not found,
# tell the user where they can go stick it
sub locate_fingerprintdb_file {
    my @possible_locations = (
        "$FindBin::Bin/fingerprints.src",      # in the same directory as this script
        "$ENV{HOME}/.fingerprints.src",
        "/etc/fingerprints.src",
        "<internal>",
        );
    foreach my $loc (@possible_locations) {
        if ($loc eq '<internal>') {
            # When fatpacked, we include the fingerprint_db file as FingerprintDB.pm.
            # But it's not available when we're not fatpacked.
            my $internal = eval q{
                use FingerprintDB;
                FingerprintDB::fingerprint_db();
            };
            return ($internal, $loc) if (defined $internal);
        }
        return (scalar(slurp($loc)), $loc) if (-e $loc);
    }
    print STDERR <<"EOF";
Error: File 'fingerprints.src' not found.

Please copy it from the installation tarball to one of these places:
    - the same directory as this script ($FindBin::Bin)
    - \$HOME/.fingerprints.src
    - /etc/fingerprints.src
EOF
    exit 1;
}


sub find_best_TERM {
    my ($fingerprint_name, $fingerprint_db) = @_;

    my $fingerprint = $fingerprint_db->{$fingerprint_name};
    my @fallback_list = 
            (exists $fingerprint->{fields}{TERM})
            ? (split '\|', $fingerprint->{fields}{TERM}{assign})
            : ($fingerprint_name);
        #print Dumper \@fallback_list; exit;

    foreach my $fallback (@fallback_list) {
        if (does_terminfo_exist($fallback)) {
            return $fallback;
        }
    }

    return undef;
}


# check the local computer's terminfo information to see if the proposed $TERM
# is found there
sub does_terminfo_exist {
    my ($term) = @_;
    # there are many ways to do this:
    #   - toe -a    (or just `toe` in Solaris)
    #   - infocmp $TERM
    #   - tput -T$TERM longname;  echo $?

    # for now, we just implement the tput one
    my $pid = fork();
    defined($pid)   or die $!;
    if (!$pid) {
        open STDOUT, '>', '/dev/null';
        open STDERR, '>', '/dev/null';
        exec "tput", "-T$term", "longname";
    }
    waitpid($pid, 0);
    my $error_value = ($? >> 8);
    return ($error_value == 0);
}


sub help_install_terminfos {
    if (`which apt-get 2>&1 `) {
        # Debian/Ubuntu/et al don't come with the full set of terminfo entries
        # installed by default, but they're easy to install
        die "    sudo apt install ncurses-term\n";
    } else {
        die <<'EOF';

    TMP=$(mktemp);
    curl http://invisible-island.net/datafiles/current/terminfo.src.gz | gzip -dc > $TMP;
    tic $TMP; rm $TMP

Run this as root if you can, but running as a normal user is fine, files will go in ~/.terminfo/
EOF
    }
}


sub show_snapshot {
    my ($fingerprint) = @_;

    # Ways to generalize the current result by using a pattern that matches
    # multiple results.
    # If one of these patterns matches, then that's really good, because it increases the 
    # chances that we'll match other results.
    #
    # Left-most are tried first, right-most tried last.
    my %generalizations = (
        r_ext_cursor_pos    => ["\e[%+R"],
        r_window_pos        => ["\e[3;%+t"],
        r_window_size_px    => ["\e[4;%+t"],
        r_window_size_char  => ["\e[8;%+t"],
        r_screen_size       => ["\e[9;%+t"],
        r_window_title      => ["\e]l%*\e\\"],
        r_window_icon_label => ["\e]L%*\e\\"],
    );
    foreach my $list (values %generalizations) {
        unshift @$list, '';         # highest priority:  match an empty string
        push    @$list, '%+';       # lowest priority:  match a non-empty string
    }
    foreach my $cap (sort keys %$fingerprint) {
        next if $Termdetect_Tests::rarely_tested_synthetics{$cap};
        my $r = summarize_result($fingerprint->{$cap});
        foreach my $gen (@{ $generalizations{$cap} }) {
            if (Termdetect_Match::match_one_field($fingerprint->{$cap}, {assign => $gen})) {
                ($r) = ansi_escape($gen);
                last;
            }
        }
        if ($cap eq 'r_device_attr2' && $fingerprint->{$cap}{received} =~ /^\e(\[>[^;]*;)[^;]*(;.*c)$/) {
            $r = "\\E$1\%+$2";
        }
        printf "    %s=%s,\n", $cap, $r;
    }
}


# quickly read a whole file         see also: File::Slurp and IO::All->slurp()
sub slurp {my$p=open(my$f,"$_[0]")or die$!;my@o=<$f>;close$f;waitpid($p,0);wantarray?@o:join("",@o)}




__END__
termdetect

  -t    Display only the matched $TERM.  Intended to be used like this:
                export TERM=$(termdetect -t)

  --nose
        "No Side Effects".  Doesn't run tests that have significant side-effects.
        Most tests don't have side-effects, so using this option doesn't greatly
        reduce the chances of correctly identifying your terminal.
        Note that there are some smaller side-effects that are unavoidable,
        even when --nose is used.  Read more at:
            https://github.com/DeeNewcum/termdetect/blob/master/doc/side-effects.md

  --snapshot
        Outputs the current fingerprint in a form that's suitable for
        cut-n-pasting into fingerprints.src.

        (the difference between this and --dump:  some fields are tweaked to include regexes that
         allow them to match a slightly wider range of values;  this is more appropriate for
         fingerprint matching, but it does obscure some of of the fine details)
        
        See here for more:
            https://github.com/DeeNewcum/termdetect/blob/master/doc/customize_fingerprintsdb.md

  --version
        Show version number.

  --help-submit
        A guide for submitting a fingerprint to the developer, so that more
        terminal types will be recognized.



  --result=<test_id>
        Display the result of a single test.  This is partiularly useful for:
            s_window_size       size of the terminal, in characters
            s_font_size         size of a single character, in pixels
            s_screen_size       size of the terminal, in pixels
            s_term_version      the terminal's version
            s_encoding          UTF-8, Shift-JIS, etc
        To get a full list of test_ids, run:      termdetect --dump

  --dump
        Dumps the current terminal's fingerprint.
        Similar to --snapshot, but gives a little more detailed information.
        See here for details on what each line means:
            https://github.com/DeeNewcum/termdetect/blob/master/doc/fingerprint_db.md

  --check=<term>
        In cases that a fingerprint can't be identified, this gives you
        information about the closest matches, including differences between the
        entries in the database and the current terminal's fingerprint.

        If no terminal name is given, it displays information about EVERY
        fingerprint in the database.
