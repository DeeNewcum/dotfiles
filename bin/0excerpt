#!/usr/bin/perl

# Searches local log files for a regular expression, and produces an .html
# report that shows the matches, as well as some nearby lines for context.
#
# The "0" prefix means, for my personal scripts and shell aliases, that these
# tools process records separated by null characters. For this particular
# script, it expects the list of filenames to search to be piped to its 
# STDIN.

    # TODO:
    #
    # - try to auto-parse some dates out of each log file line, and then add a
    #   cmdline argument that allows restriction of matches to a specific time
    #   period
    #       - date-parsing modules that might help with this:
    #           - Date::Manip::Date
    #           - Date::Parse
    #           - Time::ParseDate
    #       - For the lines that don't have any parsable date in them... should
    #         we report the count of those?   <= Maybe that would work, as long
    #         as they're a cmdline arg to suppress these warnings.

    use strict;
    use warnings;

    use File::Temp ();              # Perl core
    use Getopt::Long ();            # Perl core
    use IO::Uncompress::Gunzip ();  # Perl core
    use POSIX ();                   # Perl core
    use Text::Wrap ();              # Perl core

    use Archive::Zip qw( AZ_OK );            # not Perl core
    use Syntax::Highlight::Engine::Simple ();   # not Perl core

    use Data::Dumper;

# like grep's --before-context and --after-context
sub NUM_CONTEXT_LINES { 15 }


###########################################
## parse the command-line arguments
###########################################
sub usage {
    print <<'EOF';
usage: 0excerpt <zip_file_name> <regexp>

<zip_file_name>
        The name of the zipfile to create within /var/tmp/

<regexp>
        The Perl regexp to search all log files for.
EOF
    exit;
}

usage() unless (@ARGV >= 2);

%::ARGV = (
    zipfile => $ARGV[0],
    regexp => $ARGV[1],
);

if (-t STDIN) {
    die "A list of file names to grep should be piped into this script.\n";
}


###########################################
## read in the list of filenames
###########################################
my @local_log_files;
$/ = chr(0);            # $INPUT_RECORD_SEPARATOR
while (<STDIN>) {
    chomp;
    push @local_log_files, $_
        if (length($_));
}

    sub _wrong_delimiter {
        return unless @local_log_files;

        # "goatse operator"
        my $num_newlines =()= $local_log_files[0] =~ /\n/sg;
        if (@local_log_files == 1 && $num_newlines > 3) {
            print STDERR "\nWARNING: The list of filenames piped into 0excerpt should be null-delimited,\n"
                    . "and it looks like you may have accidentally used a newline-delimited list.\n\n";
        }
    }

_wrong_delimiter();

# do this at the very end, just to make sure the user sees it
END {
    _wrong_delimiter();
}

$/ = "\n";            # $INPUT_RECORD_SEPARATOR


###########################################
## various setup
###########################################

# set us to the lowest scheduling priority, because grepping can take a lot of
# system resources
setpriority(0, 0, 19);

my $tempdir = File::Temp::tempdir(CLEANUP => 1);
#print ">> tempdir:   $tempdir\n";

my $long_hostname = readpipe('hostname');
$long_hostname =~ s/[\n\r]+$//s;

my $short_hostname = readpipe('hostname -s');
$short_hostname =~ s/[\n\r]+$//s;


###########################################
## grep through each file
###########################################

my @last_n_lines;

## scan all log files
foreach my $logfilename (@local_log_files) {
    if (! -f $logfilename) {
        print STDERR "File '$logfilename' not found.\n";
    }

    my $logfile_fh;
    if ($logfilename =~ /\.gz$/) {
        #IO::Uncompress::Gunzip::gunzip($logfilename => \$logfile_fh)
            #or die $IO::Uncompress::Gunzip::GunzipError;
        $logfile_fh = IO::Uncompress::Gunzip->new($logfilename)
            or die $IO::Uncompress::Gunzip::GunzipError;
    } else {
        open $logfile_fh, '<', $logfilename
            or die "Error when openening $logfilename: $!\n";
    }

    ## scan one log file
    my $last_match_lineno = -999;
    while (defined(my $line = <$logfile_fh>)) {
        if ($line =~ /$ARGV{regexp}/o) {
            #print "matched $logfilename\n"; 

            # display all lines that lie within @last_n_lines
            # (this is like grep's --before-context)
            foreach my $line_ref (@last_n_lines) {
                report_file_match($logfilename, $line_ref->[1], $line_ref->[0]);
            }
            @last_n_lines = ();

            # now display this particular line
            report_file_match($logfilename, $line, $.);     # $. = $INPUT_LINE_NUMBER
            $last_match_lineno = $.;

        } elsif ($. - $last_match_lineno < NUM_CONTEXT_LINES) {
            # this is like grep's --after-context
            report_file_match($logfilename, $line, $.);     # $. = $INPUT_LINE_NUMBER

        } else {
            # this isn't a line that obviously needs to be included in the report,
            # but save it in the queue, just in case
            push @last_n_lines, [$., $line];        # $. = $INPUT_LINE_NUMBER

            # delete all but the last 'n' lines
            while (scalar(@last_n_lines) > NUM_CONTEXT_LINES) {
                shift @last_n_lines;
            }
        }
    }

    close $logfile_fh;

    process_one_report_file();
}


###############################################
## make all our changes to the zip file at once
###############################################

# initialization
my $zip = Archive::Zip->new();
if (-f $ARGV{zipfile}) {
    $zip->read($ARGV{zipfile})
        == AZ_OK or die "Error reading $ARGV{zipfile}\n";
}

delete_host_logfiles();

# update our files
$zip->addTree($tempdir, '');

# write the zip file out
if (-f $ARGV{zipfile}) {
    $zip->overwrite()
        == AZ_OK or die "Unable to write to $ARGV{zipfile}.\n";
} else {
    $zip->writeToFileNamed($ARGV{zipfile})
        == AZ_OK or die "Unable to write to $ARGV{zipfile}.\n";
}

exit;





################################################################################
## HTML report generation
################################################################################

BEGIN {
    my $last_logfilename = '';
    my $last_lineno = -1;
    my $fout;
    my $accum_line_numbers = '';     # this is the "left column-table", per https://stackoverflow.com/a/35815198/1042525
    my $accum_matches = '';          # this is the "right column-table", per https://stackoverflow.com/a/35815198/1042525
    my $highlight;

    sub report_file_match {
        my ($logfilename, $line, $lineno) = @_;

        # remove any line-endings
        $line =~ s/(\012|\015\012?)$//s;

        if (!defined($highlight)) {
            $highlight = Syntax::Highlight::Engine::Simple->new();

            # the 'class' here is the DOM/CSS class name
            $highlight->setSyntax(
                    syntax => [
                        {
                            class => 'user_regexp',
                            regexp => $ARGV{regexp},
                        },
                        {
                            class => 'error',
                            regexp => '(?i)\berror\b',
                        },
                        {
                            class => 'warning',
                            regexp => '(?i)\bwarn(ing)?\b',
                        },
                        {
                            class => 'datetime',        # this regexp is just a date
                            regexp => '\b2\d\d\d[-/]\d\d[-/]\d\d\b',
                        },
                        {
                            class => 'datetime',        # this regexp is just a time
                            regexp => '\b\d\d:\d\d(:\d\d)?\b',
                        },
                    ]
                );
        }

        if ($last_logfilename ne $logfilename) {
            if ($last_lineno >= 0) {
                process_one_report_file();
            }

            my $logfilename_fixed = $logfilename;
            $logfilename_fixed =~ s#^[/\\]##s;
            $logfilename_fixed =~ s#[/\\]#_#g;

            my $excerpt_filename = "$tempdir/${short_hostname}___$logfilename_fixed.html";
            open $fout, '>', $excerpt_filename
                or die "Unable to write to $excerpt_filename: $!\n";

            print $fout <<"EOF";
<style>
    /* useful for debugging, in cases where the line numbers get misaligned
     * from their corresponding text lines */
    /*
     body > table > tbody > tr > td {vertical-align:top}
     table table    {border:1px solid #faa}
     table table td {border:1px solid #6b6}
     td             {border:1px solid #aaf}
    */

    /* Syntax::Highlight::Engine::Simple stuff */
    .user_regexp {background-color: #ff6}
    .error       {background-color: #fcc}
    .warning     {background-color: #89f}
    .datetime {
        color: #a0a;
        font-weight: bold;
    }

    table table td {
        vertical-align: top;
        /* border:1px solid #aaa; */

        /* make all table cells look like a <pre> */
        font-family: monospace;
        white-space: pre;
    }

    /* prevent line-wraps from being copied into the clipboard */
    label {
        user-select: none;
    }


    /* ======== the line-number side ======== */
    td:nth-child(1) table {
        margin-right: 0.5em;
    }
    td:nth-child(1) table td {
        text-align: right;
    }

    table tr td:nth-child(1) table tr.ellipsis td {
        text-align: right;
        padding-top: 1em;
        padding-bottom: 1em;
        padding-right: 0.5em;
    }


    /* ======== the log-text side ======== */
    td:nth-child(2) table td {
        /* a hanging indent https://www.thesitewizard.com/css/hanging-indents.shtml */
        padding-left: 40px;
        text-indent: -40px;
    }

    table tr td:nth-child(2) table tr.ellipsis td {
        text-align: left;
        padding-top: 1em;
        padding-bottom: 1em;
        /* stop the hanging-indent */
        padding-left: 1em;
        text-indent: 0;
    }

    td.evenline {background-color:#ddd}
</style>

<title>an excerpt of $logfilename &mdash; located on $long_hostname</title>
<h1>an excerpt of $logfilename &mdash; located on $long_hostname</h1>

<table>
EOF

            $accum_line_numbers = "<!-- the line-number side -->\n"
                                    . "<table>\n";

            $accum_matches = "<!-- the log-text side -->\n"
                                    . "<table>\n";

            $last_logfilename = $logfilename;
        }

        if ($last_lineno >= 0 && $lineno - $last_lineno > 1) {
            # indicate that we just jumped to a new group of lines
            $accum_line_numbers .= "<tr class=ellipsis><td>.\n.\n.\n.\n.\n.</td></tr>\n";
            $accum_matches      .= "<tr class=ellipsis><td> \n \n \n \n \n </td></tr>\n";
        }
        $last_lineno = $lineno;

        $Text::Wrap::columns = 150;
        $line = Text::Wrap::wrap("", "", $line);
        $line =~ s/\n+$//s;
        # this is the so-called "goatse operator": it counts the number of times it matches
        my $num_extra_lines =()= $line =~ /\n/sg;
        $line = $highlight->doStr(str => $line);
        $line =~ s#\n#<label>\n</label>#sg;     # prevent line-wraps from being copied into the clipboard
        my $odd_even = ($lineno % 2) ? "oddline" : "evenline";
        $line = '&nbsp;'    if (length($line) == 0);    # if there's no text, this table cell's height gets minimized
        $accum_matches .= "<tr><td class='$odd_even'>$line</td></tr>\n";

        $accum_line_numbers .= "<tr><td>" . commify($lineno)
                . "<br/> " x $num_extra_lines
                . "</td></tr>\n";
    }

    # should be called, once, after the very last call to report_file_match()
    sub process_one_report_file {
        return unless ($last_lineno >= 0);

        print $fout "<tr><td>\n$accum_line_numbers</table>\n</td>\n",
                    "<td>\n$accum_matches</table>\n</td>\n",
                    "</table>\n";

        print $fout "<p>If you're familiar with ",
                    "<a href='https://cheatography.com/davechild/cheat-sheets/regular-expressions/'>regular expressions</a>, ",
                    "the exact regexp used here is <tt style='color: #090; font-weight: bold'>/",
                    Syntax::Highlight::Engine::Simple::_html_escape($ARGV{regexp}), "/</tt>.\n";

        # $^T is $BASETIME, the time that the program began running
        print $fout "<p>This report was generated at ", scalar(localtime($^T)), " local time ",
                    "(this system's timezone is ", POSIX::strftime("%Z", localtime()), ").\n";

        close $fout;

        print "matches were found in $last_logfilename\n";

        # reset everything, so that it's clear that this information has been
        # output already
        $last_logfilename = '';
        $last_lineno = -1;
        $fout = undef;
        $accum_line_numbers = '';
        $accum_matches = '';
    }
}


# add commas to a number
sub commify {(my$text=reverse$_[0])=~s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;scalar reverse$text}


################################################################################
## zip file handling
################################################################################

# look inside the .zip file, and if there are any files related to the current
# hostname, delete all of those files, to make sure there aren't any stale files
# left over
sub delete_host_logfiles {
    #my @members = $zip->members();
    #print Dumper \@members; exit;
    my @members = $zip->membersMatching('^' . quotemeta($short_hostname) . '___.*');

    foreach my $mmbr (@members) {
        $zip->removeMember($mmbr);
    }
}
